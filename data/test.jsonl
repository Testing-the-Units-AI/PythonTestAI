{"code": "def is_koish(board, c):\n    \"\"\"Check if c is surrounded on all sides by 1 color, and return that color\"\"\"\n    if board[c] != EMPTY:\n        return None\n    neighbors = {board[n] for n in NEIGHBORS[c]}\n    if len(neighbors) == 1 and (not EMPTY in neighbors):\n        return list(neighbors)[0]\n    else:\n        return None\ndef set_board_size(n): ...\ndef place_stones(board, color, stones): ...\ndef find_reached(board, c): ...\ndef is_koish(board, c): ...\ndef is_eyeish(board, c): ...\n", "test": "def test_is_koish(self):\n    self.assertEqual(go.is_koish(TEST_BOARD, pc('A9')), BLACK)\n    self.assertEqual(go.is_koish(TEST_BOARD, pc('B8')), None)\n    self.assertEqual(go.is_koish(TEST_BOARD, pc('B9')), None)\n    self.assertEqual(go.is_koish(TEST_BOARD, pc('E5')), None)", "framework": "unittest"}
{"code": "def is_eyeish(board, c):\n    \"\"\"Check if c is an eye, for the purpose of restricting MC rollouts.\"\"\"\n    color = is_koish(board, c)\n    if color is None:\n        return None\n    diagonal_faults = 0\n    diagonals = DIAGONALS[c]\n    if len(diagonals) < 4:\n        diagonal_faults += 1\n    for d in diagonals:\n        if not board[d] in (color, EMPTY):\n            diagonal_faults += 1\n    if diagonal_faults > 1:\n        return None\n    else:\n        return color\ndef set_board_size(n): ...\ndef place_stones(board, color, stones): ...\ndef find_reached(board, c): ...\ndef is_koish(board, c): ...\ndef is_eyeish(board, c): ...\n", "test": "def test_is_eyeish(self):\n    board = load_board('\\n            .XX...XXX\\n            X.X...X.X\\n            XX.....X.\\n            ........X\\n            XXXX.....\\n            OOOX....O\\n            X.OXX.OO.\\n            .XO.X.O.O\\n            XXO.X.OO.\\n        ')\n    B_eyes = pc_set('A2 A9 B8 J7 H8')\n    W_eyes = pc_set('H2 J1 J3')\n    not_eyes = pc_set('B3 E5')\n    for be in B_eyes:\n        self.assertEqual(go.is_eyeish(board, be), BLACK, str(be))\n    for we in W_eyes:\n        self.assertEqual(go.is_eyeish(board, we), WHITE, str(we))\n    for ne in not_eyes:\n        self.assertEqual(go.is_eyeish(board, ne), None, str(ne))", "framework": "unittest"}
{"code": "class LibertyTracker():\n    def add_stone(self, color, c):\n        assert self.group_index[c] == MISSING_GROUP_ID\n        captured_stones = set()\n        opponent_neighboring_group_ids = set()\n        friendly_neighboring_group_ids = set()\n        empty_neighbors = set()\n        for n in NEIGHBORS[c]:\n            neighbor_group_id = self.group_index[n]\n            if neighbor_group_id != MISSING_GROUP_ID:\n                neighbor_group = self.groups[neighbor_group_id]\n                if neighbor_group.color == color:\n                    friendly_neighboring_group_ids.add(neighbor_group_id)\n                else:\n                    opponent_neighboring_group_ids.add(neighbor_group_id)\n            else:\n                empty_neighbors.add(n)\n        new_group = self._create_group(color, c, empty_neighbors)\n        for group_id in friendly_neighboring_group_ids:\n            new_group = self._merge_groups(group_id, new_group.id)\n        for group_id in opponent_neighboring_group_ids:\n            neighbor_group = self.groups[group_id]\n            if len(neighbor_group.liberties) == 1:\n                captured = self._capture_group(group_id)\n                captured_stones.update(captured)\n            else:\n                self._update_liberties(group_id, remove={c})\n        self._handle_captures(captured_stones)\n        if len(new_group.liberties) == 0:\n            raise IllegalMove\n        return captured_stones\n    \n    def from_board(board): ...\n    def __init__(self, group_index=None, groups=None, liberty_cache=None, max_group_id=1): ...\n    def __deepcopy__(self, memodict={}): ...\n    def _create_group(self, color, c, liberties): ...\n    def _merge_groups(self, group1_id, group2_id): ...\n    def _capture_group(self, group_id): ...\n    def _update_liberties(self, group_id, add=None, remove=None): ...\n    def _handle_captures(self, captured_stones): ...\n\n    self.group_index = group_index if group_index is not None else -np.ones([N, N], dtype=np.int16)\n    self.groups = groups or {}\n    self.liberty_cache = liberty_cache if liberty_cache is not None else np.zeros([N, N], dtype=np.uint8)\n    self.max_group_id = max_group_id\n", "test": "def test_place_stone(self):\n    board = load_board('X........' + EMPTY_ROW * 8)\n    lib_tracker = LibertyTracker.from_board(board)\n    lib_tracker.add_stone(BLACK, pc('B9'))\n    self.assertEqual(len(lib_tracker.groups), 1)\n    self.assertNotEqual(lib_tracker.group_index[pc('A9')], go.MISSING_GROUP_ID)\n    self.assertEqual(lib_tracker.liberty_cache[pc('A9')], 3)\n    self.assertEqual(lib_tracker.liberty_cache[pc('B9')], 3)\n    sole_group = lib_tracker.groups[lib_tracker.group_index[pc('A9')]]\n    self.assertEqual(sole_group.stones, pc_set('A9 B9'))\n    self.assertEqual(sole_group.liberties, pc_set('C9 A8 B8'))\n    self.assertEqual(sole_group.color, BLACK)", "framework": "unittest"}
{"code": "class LibertyTracker():\n    def add_stone(self, color, c):\n        assert self.group_index[c] == MISSING_GROUP_ID\n        captured_stones = set()\n        opponent_neighboring_group_ids = set()\n        friendly_neighboring_group_ids = set()\n        empty_neighbors = set()\n        for n in NEIGHBORS[c]:\n            neighbor_group_id = self.group_index[n]\n            if neighbor_group_id != MISSING_GROUP_ID:\n                neighbor_group = self.groups[neighbor_group_id]\n                if neighbor_group.color == color:\n                    friendly_neighboring_group_ids.add(neighbor_group_id)\n                else:\n                    opponent_neighboring_group_ids.add(neighbor_group_id)\n            else:\n                empty_neighbors.add(n)\n        new_group = self._create_group(color, c, empty_neighbors)\n        for group_id in friendly_neighboring_group_ids:\n            new_group = self._merge_groups(group_id, new_group.id)\n        for group_id in opponent_neighboring_group_ids:\n            neighbor_group = self.groups[group_id]\n            if len(neighbor_group.liberties) == 1:\n                captured = self._capture_group(group_id)\n                captured_stones.update(captured)\n            else:\n                self._update_liberties(group_id, remove={c})\n        self._handle_captures(captured_stones)\n        if len(new_group.liberties) == 0:\n            raise IllegalMove\n        return captured_stones\n    \n    def from_board(board): ...\n    def __init__(self, group_index=None, groups=None, liberty_cache=None, max_group_id=1): ...\n    def __deepcopy__(self, memodict={}): ...\n    def _create_group(self, color, c, liberties): ...\n    def _merge_groups(self, group1_id, group2_id): ...\n    def _capture_group(self, group_id): ...\n    def _update_liberties(self, group_id, add=None, remove=None): ...\n    def _handle_captures(self, captured_stones): ...\n\n    self.group_index = group_index if group_index is not None else -np.ones([N, N], dtype=np.int16)\n    self.groups = groups or {}\n    self.liberty_cache = liberty_cache if liberty_cache is not None else np.zeros([N, N], dtype=np.uint8)\n    self.max_group_id = max_group_id\n", "test": "def test_capture_stone(self):\n    board = load_board('\\n            .X.......\\n            XO.......\\n            .X.......\\n        ' + EMPTY_ROW * 6)\n    lib_tracker = LibertyTracker.from_board(board)\n    captured = lib_tracker.add_stone(BLACK, pc('C8'))\n    self.assertEqual(len(lib_tracker.groups), 4)\n    self.assertEqual(lib_tracker.group_index[pc('B8')], go.MISSING_GROUP_ID)\n    self.assertEqual(captured, pc_set('B8'))", "framework": "unittest"}
{"code": "class Position():\n    def flip_playerturn(self, mutate=False):\n        pos = self if mutate else copy.deepcopy(self)\n        pos.ko = None\n        pos.to_play *= -1\n        return pos\n    \n    def __init__(self, board=None, n=0, komi=7.5, caps=(0, 0), lib_tracker=None, ko=None, recent=tuple(), to_play=BLACK): ...\n    def __deepcopy__(self, memodict={}): ...\n    def __str__(self): ...\n    def is_move_suicidal(self, move): ...\n    def is_move_legal(self, move): ...\n    def pass_move(self, mutate=False): ...\n    def get_liberties(self): ...\n    def play_move(self, c, color=None, mutate=False): ...\n    def score(self): ...\n    def result(self): ...\n\n    self.board = board if board is not None else np.copy(EMPTY_BOARD)\n    self.n = n\n    self.komi = komi\n    self.caps = caps\n    self.lib_tracker = lib_tracker or LibertyTracker.from_board(self.board)\n    self.ko = ko\n    self.recent = recent\n    self.to_play = to_play\n", "test": "def test_flipturn(self):\n    start_position = Position(board=TEST_BOARD, n=0, komi=6.5, caps=(1, 2), ko=pc('A1'), recent=tuple(), to_play=BLACK)\n    expected_position = Position(board=TEST_BOARD, n=0, komi=6.5, caps=(1, 2), ko=None, recent=tuple(), to_play=WHITE)\n    flip_position = start_position.flip_playerturn()\n    self.assertEqualPositions(flip_position, expected_position)", "framework": "unittest"}
{"code": "class Position():\n    def is_move_suicidal(self, move):\n        potential_libs = set()\n        for n in NEIGHBORS[move]:\n            neighbor_group_id = self.lib_tracker.group_index[n]\n            if neighbor_group_id == MISSING_GROUP_ID:\n                return False\n            neighbor_group = self.lib_tracker.groups[neighbor_group_id]\n            if neighbor_group.color == self.to_play:\n                potential_libs |= neighbor_group.liberties\n            elif len(neighbor_group.liberties) == 1:\n                return False\n        potential_libs -= set([move])\n        return not potential_libs\n    \n    def __init__(self, board=None, n=0, komi=7.5, caps=(0, 0), lib_tracker=None, ko=None, recent=tuple(), to_play=BLACK): ...\n    def __deepcopy__(self, memodict={}): ...\n    def __str__(self): ...\n    def is_move_legal(self, move): ...\n    def pass_move(self, mutate=False): ...\n    def flip_playerturn(self, mutate=False): ...\n    def get_liberties(self): ...\n    def play_move(self, c, color=None, mutate=False): ...\n    def score(self): ...\n    def result(self): ...\n\n    self.board = board if board is not None else np.copy(EMPTY_BOARD)\n    self.n = n\n    self.komi = komi\n    self.caps = caps\n    self.lib_tracker = lib_tracker or LibertyTracker.from_board(self.board)\n    self.ko = ko\n    self.recent = recent\n    self.to_play = to_play\n", "test": "def test_is_move_suicidal(self):\n    board = load_board('\\n            ...O.O...\\n            ....O....\\n            XO.....O.\\n            OXO...OXO\\n            O.XO.OX.O\\n            OXO...OOX\\n            XO.......\\n            ......XXO\\n            .....XOO.\\n        ')\n    position = Position(board=board, to_play=BLACK)\n    suicidal_moves = pc_set('E9 H5')\n    nonsuicidal_moves = pc_set('B5 J1 A9')\n    for move in suicidal_moves:\n        assert position.board[move] == go.EMPTY\n        self.assertTrue(position.is_move_suicidal(move), str(move))\n    for move in nonsuicidal_moves:\n        assert position.board[move] == go.EMPTY\n        self.assertFalse(position.is_move_suicidal(move), str(move))", "framework": "unittest"}
{"code": "class Position():\n    def play_move(self, c, color=None, mutate=False):\n        if color is None:\n            color = self.to_play\n        pos = self if mutate else copy.deepcopy(self)\n        if c is None:\n            pos = pos.pass_move(mutate=mutate)\n            return pos\n        if not self.is_move_legal(c):\n            raise IllegalMove()\n        place_stones(pos.board, color, [c])\n        captured_stones = pos.lib_tracker.add_stone(color, c)\n        place_stones(pos.board, EMPTY, captured_stones)\n        opp_color = color * -1\n        if len(captured_stones) == 1 and is_koish(self.board, c) == opp_color:\n            new_ko = list(captured_stones)[0]\n        else:\n            new_ko = None\n        if pos.to_play == BLACK:\n            new_caps = (pos.caps[0] + len(captured_stones), pos.caps[1])\n        else:\n            new_caps = (pos.caps[0], pos.caps[1] + len(captured_stones))\n        pos.n += 1\n        pos.caps = new_caps\n        pos.ko = new_ko\n        pos.recent += (PlayerMove(color, c),)\n        pos.to_play *= -1\n        return pos\n    \n    def __init__(self, board=None, n=0, komi=7.5, caps=(0, 0), lib_tracker=None, ko=None, recent=tuple(), to_play=BLACK): ...\n    def __deepcopy__(self, memodict={}): ...\n    def __str__(self): ...\n    def is_move_suicidal(self, move): ...\n    def is_move_legal(self, move): ...\n    def pass_move(self, mutate=False): ...\n    def flip_playerturn(self, mutate=False): ...\n    def get_liberties(self): ...\n    def score(self): ...\n    def result(self): ...\n\n    self.board = board if board is not None else np.copy(EMPTY_BOARD)\n    self.n = n\n    self.komi = komi\n    self.caps = caps\n    self.lib_tracker = lib_tracker or LibertyTracker.from_board(self.board)\n    self.ko = ko\n    self.recent = recent\n    self.to_play = to_play\n", "test": "def test_legal_moves(self):\n    board = load_board('\\n            .XXXXXXXO\\n            XX.OOOOO.\\n            OOOOOOOOO\\n            XXXXXXXX.\\n            OOOOOOOOO\\n            XXXXXXXXX\\n            XXXXXXXXX\\n            XXXXXXXXX\\n            XXXXXXXX.\\n        ')\n    position = Position(board=board, n=0, komi=6.5, caps=(0, 0), ko=pc('J8'), recent=tuple(), to_play=BLACK)\n    empty_spots = pc_set('A9 C8 J8 J6 J1')\n    B_legal_moves = pc_set('A9 C8 J6')\n    for move in empty_spots:\n        if move not in B_legal_moves:\n            with self.assertRaises(go.IllegalMove):\n                position.play_move(move)\n        else:\n            position.play_move(move)\n    position.play_move(None)\n    pass_position = position.pass_move()\n    W_legal_moves = pc_set('C8 J8 J6 J1')\n    for move in empty_spots:\n        if move not in W_legal_moves:\n            with self.assertRaises(go.IllegalMove):\n                pass_position.play_move(move)\n        else:\n            pass_position.play_move(move)\n    pass_position.play_move(None)", "framework": "unittest"}
{"code": "class Links(object):\n    def link_term(self, term_str):\n        if term_str not in self._linked_terms:\n            self._linked_terms.append(term_str)\n    \n    def __init__(self): ...\n    def __str__(self): ...\n    def _link_image(self, path): ...\n    def _link_file(self, path): ...\n    def unlink_term(self, term_str): ...\n    def unlink_file(self, path: Path): ...\n    def save(self, path: Path, description_images: list()): ...\n    def _delete_removed_files(self, description_images: list()): ...\n    def _save_files_to_term_path(self, description_images: list): ...\n    def load(self, path: Path): ...\n    def link_file_on_mime(self, path: Path): ...\n    def delete(self): ...\n    def linked_terms(self): ...\n    def linked_images(self): ...\n    def linked_files(self): ...\n    def get_file_path(self, file_name: str): ...\n    def get_non_project_file_path(self, file_name: str): ...\n    def path(self): ...\n    def path(self, path: Path): ...\n\n    self._linked_terms = []\n    self._linked_files = dict()\n    self._linked_images = dict()\n    self._to_delete = list()\n    self._path = None\n", "test": "@pytest.mark.randomize(name=str, str_attrs=('digits', 'whitespace', 'ascii_letters'), ncalls=10)\ndef test_link_unlink_term(self, name):\n    links = Links()\n    links.link_term(name)\n    assert name in links.linked_terms", "framework": "pytest"}
{"code": "class Links(object):\n    def load(self, path: Path):\n        self._path = path\n        dictionary = load_json(self._path / 'links.json', LinksDecoder())\n        if type(dictionary) is dict:\n            self._linked_terms = dictionary.get('terms')\n        if self._path.is_dir():\n            for file in self._path.iterdir():\n                if file.is_file and file.name not in ['links.json', 'description.json']:\n                    self.link_file_on_mime(Path(file.name))\n        logging.debug('links after load: ' + str(self.linked_images) + ' ' + str(self.linked_files) + ' ' + str(self.linked_terms))\n    \n    def __init__(self): ...\n    def __str__(self): ...\n    def link_term(self, term_str): ...\n    def _link_image(self, path): ...\n    def _link_file(self, path): ...\n    def unlink_term(self, term_str): ...\n    def unlink_file(self, path: Path): ...\n    def save(self, path: Path, description_images: list()): ...\n    def _delete_removed_files(self, description_images: list()): ...\n    def _save_files_to_term_path(self, description_images: list): ...\n    def link_file_on_mime(self, path: Path): ...\n    def delete(self): ...\n    def linked_terms(self): ...\n    def linked_images(self): ...\n    def linked_files(self): ...\n    def get_file_path(self, file_name: str): ...\n    def get_non_project_file_path(self, file_name: str): ...\n    def path(self): ...\n    def path(self, path: Path): ...\n\n    self._linked_terms = []\n    self._linked_files = dict()\n    self._linked_images = dict()\n    self._to_delete = list()\n    self._path = None\n", "test": "@pytest.mark.randomize(name=str, str_attrs=('digits', 'whitespace', 'ascii_letters'), ncalls=300)\ndef test_link_save_load(self, name):\n    links = Links()\n    links.link_term(name)\n    assert name in links.linked_terms\n    links.save(Path('/tmp/'), [])\n    links = Links()\n    links.load(Path('/tmp/'))\n    assert name in links.linked_terms", "framework": "pytest"}
