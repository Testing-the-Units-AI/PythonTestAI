{"code": "def is_koish(board, c):\n    \"\"\"Check if c is surrounded on all sides by 1 color, and return that color\"\"\"\n    if board[c] != EMPTY:\n        return None\n    neighbors = {board[n] for n in NEIGHBORS[c]}\n    if len(neighbors) == 1 and (not EMPTY in neighbors):\n        return list(neighbors)[0]\n    else:\n        return None\ndef set_board_size(n): ...\ndef place_stones(board, color, stones): ...\ndef find_reached(board, c): ...\ndef is_koish(board, c): ...\ndef is_eyeish(board, c): ...\n", "test": "def test_is_koish(self):\n    self.assertEqual(go.is_koish(TEST_BOARD, pc('A9')), BLACK)\n    self.assertEqual(go.is_koish(TEST_BOARD, pc('B8')), None)\n    self.assertEqual(go.is_koish(TEST_BOARD, pc('B9')), None)\n    self.assertEqual(go.is_koish(TEST_BOARD, pc('E5')), None)", "framework": "unittest"}
{"code": "def is_eyeish(board, c):\n    \"\"\"Check if c is an eye, for the purpose of restricting MC rollouts.\"\"\"\n    color = is_koish(board, c)\n    if color is None:\n        return None\n    diagonal_faults = 0\n    diagonals = DIAGONALS[c]\n    if len(diagonals) < 4:\n        diagonal_faults += 1\n    for d in diagonals:\n        if not board[d] in (color, EMPTY):\n            diagonal_faults += 1\n    if diagonal_faults > 1:\n        return None\n    else:\n        return color\ndef set_board_size(n): ...\ndef place_stones(board, color, stones): ...\ndef find_reached(board, c): ...\ndef is_koish(board, c): ...\ndef is_eyeish(board, c): ...\n", "test": "def test_is_eyeish(self):\n    board = load_board('\\n            .XX...XXX\\n            X.X...X.X\\n            XX.....X.\\n            ........X\\n            XXXX.....\\n            OOOX....O\\n            X.OXX.OO.\\n            .XO.X.O.O\\n            XXO.X.OO.\\n        ')\n    B_eyes = pc_set('A2 A9 B8 J7 H8')\n    W_eyes = pc_set('H2 J1 J3')\n    not_eyes = pc_set('B3 E5')\n    for be in B_eyes:\n        self.assertEqual(go.is_eyeish(board, be), BLACK, str(be))\n    for we in W_eyes:\n        self.assertEqual(go.is_eyeish(board, we), WHITE, str(we))\n    for ne in not_eyes:\n        self.assertEqual(go.is_eyeish(board, ne), None, str(ne))", "framework": "unittest"}
{"code": "class LibertyTracker():\n    def add_stone(self, color, c):\n        assert self.group_index[c] == MISSING_GROUP_ID\n        captured_stones = set()\n        opponent_neighboring_group_ids = set()\n        friendly_neighboring_group_ids = set()\n        empty_neighbors = set()\n        for n in NEIGHBORS[c]:\n            neighbor_group_id = self.group_index[n]\n            if neighbor_group_id != MISSING_GROUP_ID:\n                neighbor_group = self.groups[neighbor_group_id]\n                if neighbor_group.color == color:\n                    friendly_neighboring_group_ids.add(neighbor_group_id)\n                else:\n                    opponent_neighboring_group_ids.add(neighbor_group_id)\n            else:\n                empty_neighbors.add(n)\n        new_group = self._create_group(color, c, empty_neighbors)\n        for group_id in friendly_neighboring_group_ids:\n            new_group = self._merge_groups(group_id, new_group.id)\n        for group_id in opponent_neighboring_group_ids:\n            neighbor_group = self.groups[group_id]\n            if len(neighbor_group.liberties) == 1:\n                captured = self._capture_group(group_id)\n                captured_stones.update(captured)\n            else:\n                self._update_liberties(group_id, remove={c})\n        self._handle_captures(captured_stones)\n        if len(new_group.liberties) == 0:\n            raise IllegalMove\n        return captured_stones\n    \n    def from_board(board): ...\n    def __init__(self, group_index=None, groups=None, liberty_cache=None, max_group_id=1): ...\n    def __deepcopy__(self, memodict={}): ...\n    def _create_group(self, color, c, liberties): ...\n    def _merge_groups(self, group1_id, group2_id): ...\n    def _capture_group(self, group_id): ...\n    def _update_liberties(self, group_id, add=None, remove=None): ...\n    def _handle_captures(self, captured_stones): ...\n\n    self.group_index = group_index if group_index is not None else -np.ones([N, N], dtype=np.int16)\n    self.groups = groups or {}\n    self.liberty_cache = liberty_cache if liberty_cache is not None else np.zeros([N, N], dtype=np.uint8)\n    self.max_group_id = max_group_id\n", "test": "def test_place_stone(self):\n    board = load_board('X........' + EMPTY_ROW * 8)\n    lib_tracker = LibertyTracker.from_board(board)\n    lib_tracker.add_stone(BLACK, pc('B9'))\n    self.assertEqual(len(lib_tracker.groups), 1)\n    self.assertNotEqual(lib_tracker.group_index[pc('A9')], go.MISSING_GROUP_ID)\n    self.assertEqual(lib_tracker.liberty_cache[pc('A9')], 3)\n    self.assertEqual(lib_tracker.liberty_cache[pc('B9')], 3)\n    sole_group = lib_tracker.groups[lib_tracker.group_index[pc('A9')]]\n    self.assertEqual(sole_group.stones, pc_set('A9 B9'))\n    self.assertEqual(sole_group.liberties, pc_set('C9 A8 B8'))\n    self.assertEqual(sole_group.color, BLACK)", "framework": "unittest"}
{"code": "class LibertyTracker():\n    def add_stone(self, color, c):\n        assert self.group_index[c] == MISSING_GROUP_ID\n        captured_stones = set()\n        opponent_neighboring_group_ids = set()\n        friendly_neighboring_group_ids = set()\n        empty_neighbors = set()\n        for n in NEIGHBORS[c]:\n            neighbor_group_id = self.group_index[n]\n            if neighbor_group_id != MISSING_GROUP_ID:\n                neighbor_group = self.groups[neighbor_group_id]\n                if neighbor_group.color == color:\n                    friendly_neighboring_group_ids.add(neighbor_group_id)\n                else:\n                    opponent_neighboring_group_ids.add(neighbor_group_id)\n            else:\n                empty_neighbors.add(n)\n        new_group = self._create_group(color, c, empty_neighbors)\n        for group_id in friendly_neighboring_group_ids:\n            new_group = self._merge_groups(group_id, new_group.id)\n        for group_id in opponent_neighboring_group_ids:\n            neighbor_group = self.groups[group_id]\n            if len(neighbor_group.liberties) == 1:\n                captured = self._capture_group(group_id)\n                captured_stones.update(captured)\n            else:\n                self._update_liberties(group_id, remove={c})\n        self._handle_captures(captured_stones)\n        if len(new_group.liberties) == 0:\n            raise IllegalMove\n        return captured_stones\n    \n    def from_board(board): ...\n    def __init__(self, group_index=None, groups=None, liberty_cache=None, max_group_id=1): ...\n    def __deepcopy__(self, memodict={}): ...\n    def _create_group(self, color, c, liberties): ...\n    def _merge_groups(self, group1_id, group2_id): ...\n    def _capture_group(self, group_id): ...\n    def _update_liberties(self, group_id, add=None, remove=None): ...\n    def _handle_captures(self, captured_stones): ...\n\n    self.group_index = group_index if group_index is not None else -np.ones([N, N], dtype=np.int16)\n    self.groups = groups or {}\n    self.liberty_cache = liberty_cache if liberty_cache is not None else np.zeros([N, N], dtype=np.uint8)\n    self.max_group_id = max_group_id\n", "test": "def test_capture_stone(self):\n    board = load_board('\\n            .X.......\\n            XO.......\\n            .X.......\\n        ' + EMPTY_ROW * 6)\n    lib_tracker = LibertyTracker.from_board(board)\n    captured = lib_tracker.add_stone(BLACK, pc('C8'))\n    self.assertEqual(len(lib_tracker.groups), 4)\n    self.assertEqual(lib_tracker.group_index[pc('B8')], go.MISSING_GROUP_ID)\n    self.assertEqual(captured, pc_set('B8'))", "framework": "unittest"}
{"code": "class Position():\n    def flip_playerturn(self, mutate=False):\n        pos = self if mutate else copy.deepcopy(self)\n        pos.ko = None\n        pos.to_play *= -1\n        return pos\n    \n    def __init__(self, board=None, n=0, komi=7.5, caps=(0, 0), lib_tracker=None, ko=None, recent=tuple(), to_play=BLACK): ...\n    def __deepcopy__(self, memodict={}): ...\n    def __str__(self): ...\n    def is_move_suicidal(self, move): ...\n    def is_move_legal(self, move): ...\n    def pass_move(self, mutate=False): ...\n    def get_liberties(self): ...\n    def play_move(self, c, color=None, mutate=False): ...\n    def score(self): ...\n    def result(self): ...\n\n    self.board = board if board is not None else np.copy(EMPTY_BOARD)\n    self.n = n\n    self.komi = komi\n    self.caps = caps\n    self.lib_tracker = lib_tracker or LibertyTracker.from_board(self.board)\n    self.ko = ko\n    self.recent = recent\n    self.to_play = to_play\n", "test": "def test_flipturn(self):\n    start_position = Position(board=TEST_BOARD, n=0, komi=6.5, caps=(1, 2), ko=pc('A1'), recent=tuple(), to_play=BLACK)\n    expected_position = Position(board=TEST_BOARD, n=0, komi=6.5, caps=(1, 2), ko=None, recent=tuple(), to_play=WHITE)\n    flip_position = start_position.flip_playerturn()\n    self.assertEqualPositions(flip_position, expected_position)", "framework": "unittest"}
{"code": "class Position():\n    def is_move_suicidal(self, move):\n        potential_libs = set()\n        for n in NEIGHBORS[move]:\n            neighbor_group_id = self.lib_tracker.group_index[n]\n            if neighbor_group_id == MISSING_GROUP_ID:\n                return False\n            neighbor_group = self.lib_tracker.groups[neighbor_group_id]\n            if neighbor_group.color == self.to_play:\n                potential_libs |= neighbor_group.liberties\n            elif len(neighbor_group.liberties) == 1:\n                return False\n        potential_libs -= set([move])\n        return not potential_libs\n    \n    def __init__(self, board=None, n=0, komi=7.5, caps=(0, 0), lib_tracker=None, ko=None, recent=tuple(), to_play=BLACK): ...\n    def __deepcopy__(self, memodict={}): ...\n    def __str__(self): ...\n    def is_move_legal(self, move): ...\n    def pass_move(self, mutate=False): ...\n    def flip_playerturn(self, mutate=False): ...\n    def get_liberties(self): ...\n    def play_move(self, c, color=None, mutate=False): ...\n    def score(self): ...\n    def result(self): ...\n\n    self.board = board if board is not None else np.copy(EMPTY_BOARD)\n    self.n = n\n    self.komi = komi\n    self.caps = caps\n    self.lib_tracker = lib_tracker or LibertyTracker.from_board(self.board)\n    self.ko = ko\n    self.recent = recent\n    self.to_play = to_play\n", "test": "def test_is_move_suicidal(self):\n    board = load_board('\\n            ...O.O...\\n            ....O....\\n            XO.....O.\\n            OXO...OXO\\n            O.XO.OX.O\\n            OXO...OOX\\n            XO.......\\n            ......XXO\\n            .....XOO.\\n        ')\n    position = Position(board=board, to_play=BLACK)\n    suicidal_moves = pc_set('E9 H5')\n    nonsuicidal_moves = pc_set('B5 J1 A9')\n    for move in suicidal_moves:\n        assert position.board[move] == go.EMPTY\n        self.assertTrue(position.is_move_suicidal(move), str(move))\n    for move in nonsuicidal_moves:\n        assert position.board[move] == go.EMPTY\n        self.assertFalse(position.is_move_suicidal(move), str(move))", "framework": "unittest"}
{"code": "class Position():\n    def play_move(self, c, color=None, mutate=False):\n        if color is None:\n            color = self.to_play\n        pos = self if mutate else copy.deepcopy(self)\n        if c is None:\n            pos = pos.pass_move(mutate=mutate)\n            return pos\n        if not self.is_move_legal(c):\n            raise IllegalMove()\n        place_stones(pos.board, color, [c])\n        captured_stones = pos.lib_tracker.add_stone(color, c)\n        place_stones(pos.board, EMPTY, captured_stones)\n        opp_color = color * -1\n        if len(captured_stones) == 1 and is_koish(self.board, c) == opp_color:\n            new_ko = list(captured_stones)[0]\n        else:\n            new_ko = None\n        if pos.to_play == BLACK:\n            new_caps = (pos.caps[0] + len(captured_stones), pos.caps[1])\n        else:\n            new_caps = (pos.caps[0], pos.caps[1] + len(captured_stones))\n        pos.n += 1\n        pos.caps = new_caps\n        pos.ko = new_ko\n        pos.recent += (PlayerMove(color, c),)\n        pos.to_play *= -1\n        return pos\n    \n    def __init__(self, board=None, n=0, komi=7.5, caps=(0, 0), lib_tracker=None, ko=None, recent=tuple(), to_play=BLACK): ...\n    def __deepcopy__(self, memodict={}): ...\n    def __str__(self): ...\n    def is_move_suicidal(self, move): ...\n    def is_move_legal(self, move): ...\n    def pass_move(self, mutate=False): ...\n    def flip_playerturn(self, mutate=False): ...\n    def get_liberties(self): ...\n    def score(self): ...\n    def result(self): ...\n\n    self.board = board if board is not None else np.copy(EMPTY_BOARD)\n    self.n = n\n    self.komi = komi\n    self.caps = caps\n    self.lib_tracker = lib_tracker or LibertyTracker.from_board(self.board)\n    self.ko = ko\n    self.recent = recent\n    self.to_play = to_play\n", "test": "def test_legal_moves(self):\n    board = load_board('\\n            .XXXXXXXO\\n            XX.OOOOO.\\n            OOOOOOOOO\\n            XXXXXXXX.\\n            OOOOOOOOO\\n            XXXXXXXXX\\n            XXXXXXXXX\\n            XXXXXXXXX\\n            XXXXXXXX.\\n        ')\n    position = Position(board=board, n=0, komi=6.5, caps=(0, 0), ko=pc('J8'), recent=tuple(), to_play=BLACK)\n    empty_spots = pc_set('A9 C8 J8 J6 J1')\n    B_legal_moves = pc_set('A9 C8 J6')\n    for move in empty_spots:\n        if move not in B_legal_moves:\n            with self.assertRaises(go.IllegalMove):\n                position.play_move(move)\n        else:\n            position.play_move(move)\n    position.play_move(None)\n    pass_position = position.pass_move()\n    W_legal_moves = pc_set('C8 J8 J6 J1')\n    for move in empty_spots:\n        if move not in W_legal_moves:\n            with self.assertRaises(go.IllegalMove):\n                pass_position.play_move(move)\n        else:\n            pass_position.play_move(move)\n    pass_position.play_move(None)", "framework": "unittest"}
{"code": "class Links(object):\n    def link_term(self, term_str):\n        if term_str not in self._linked_terms:\n            self._linked_terms.append(term_str)\n    \n    def __init__(self): ...\n    def __str__(self): ...\n    def _link_image(self, path): ...\n    def _link_file(self, path): ...\n    def unlink_term(self, term_str): ...\n    def unlink_file(self, path: Path): ...\n    def save(self, path: Path, description_images: list()): ...\n    def _delete_removed_files(self, description_images: list()): ...\n    def _save_files_to_term_path(self, description_images: list): ...\n    def load(self, path: Path): ...\n    def link_file_on_mime(self, path: Path): ...\n    def delete(self): ...\n    def linked_terms(self): ...\n    def linked_images(self): ...\n    def linked_files(self): ...\n    def get_file_path(self, file_name: str): ...\n    def get_non_project_file_path(self, file_name: str): ...\n    def path(self): ...\n    def path(self, path: Path): ...\n\n    self._linked_terms = []\n    self._linked_files = dict()\n    self._linked_images = dict()\n    self._to_delete = list()\n    self._path = None\n", "test": "@pytest.mark.randomize(name=str, str_attrs=('digits', 'whitespace', 'ascii_letters'), ncalls=10)\ndef test_link_unlink_term(self, name):\n    links = Links()\n    links.link_term(name)\n    assert name in links.linked_terms", "framework": "pytest"}
{"code": "class Links(object):\n    def load(self, path: Path):\n        self._path = path\n        dictionary = load_json(self._path / 'links.json', LinksDecoder())\n        if type(dictionary) is dict:\n            self._linked_terms = dictionary.get('terms')\n        if self._path.is_dir():\n            for file in self._path.iterdir():\n                if file.is_file and file.name not in ['links.json', 'description.json']:\n                    self.link_file_on_mime(Path(file.name))\n        logging.debug('links after load: ' + str(self.linked_images) + ' ' + str(self.linked_files) + ' ' + str(self.linked_terms))\n    \n    def __init__(self): ...\n    def __str__(self): ...\n    def link_term(self, term_str): ...\n    def _link_image(self, path): ...\n    def _link_file(self, path): ...\n    def unlink_term(self, term_str): ...\n    def unlink_file(self, path: Path): ...\n    def save(self, path: Path, description_images: list()): ...\n    def _delete_removed_files(self, description_images: list()): ...\n    def _save_files_to_term_path(self, description_images: list): ...\n    def link_file_on_mime(self, path: Path): ...\n    def delete(self): ...\n    def linked_terms(self): ...\n    def linked_images(self): ...\n    def linked_files(self): ...\n    def get_file_path(self, file_name: str): ...\n    def get_non_project_file_path(self, file_name: str): ...\n    def path(self): ...\n    def path(self, path: Path): ...\n\n    self._linked_terms = []\n    self._linked_files = dict()\n    self._linked_images = dict()\n    self._to_delete = list()\n    self._path = None\n", "test": "@pytest.mark.randomize(name=str, str_attrs=('digits', 'whitespace', 'ascii_letters'), ncalls=300)\ndef test_link_save_load(self, name):\n    links = Links()\n    links.link_term(name)\n    assert name in links.linked_terms\n    links.save(Path('/tmp/'), [])\n    links = Links()\n    links.load(Path('/tmp/'))\n    assert name in links.linked_terms", "framework": "pytest"}
{"code": "def deviation_to_csv(fname, md, inc, azi, fmt='%.3f', delimiter=',', header='md,inc,azi', **kwargs):\n    \"\"\"Write a log to a comma-separated values (csv) file.\n\n    Parameters\n    ----------\n    fname : str or file handle\n        file path or object the CSV will be written to.\n    md : array-like,\n        measured depth\n    inc : array-like,\n        inclination from vertical\n    azi : array-like,\n        azimuth from north\n    fmt : str\n        this is the fmt argument to numpy.savetxt, see:\n        https://numpy.org/doc/stable/reference/generated/numpy.savetxt.html\n    delimiter : str\n        String or character separating columns.\n    header : str\n        String that will be written at the beginning of the file.\n        Beware if changing the header that it does not change the order in\n        which the data are written, which remains: `md`,`inc`,`azi`.\n\n    Other Parameters\n    ----------------\n    **kwargs : All other keyword arguments are passed to `np.savetxt`\n\n    Notes\n    -----\n    This function is totally unit unaware, the user is responsible\n    to handle units.\n\n    Caution: deviation_to_csv uses Python write mode set to the default: \u2018w\u2019\n    therefore existing files will be overwritten.\n    \"\"\"\n    md, inc, azi = checkarrays(md, inc, azi)\n    a = np.asarray([md, inc, azi])\n    np.savetxt(fname, a, fmt=fmt, delimiter=delimiter, header=header, **kwargs)\n    return None\ndef deviation_to_csv(fname, md, inc, azi, fmt='%.3f', delimiter=',', header='md,inc,azi', **kwargs): ...\ndef position_to_csv(fname, depth, northing, easting, fmt='%.3f', delimiter=',', header='easting,northing,depth', **kwargs): ...\n", "test": "def test_deviation_not_floats_throws():\n    output = io.StringIO()\n    md, inc, azi = (_md.copy(), _inc.copy(), _azi.copy())\n    for val in [md, inc, azi]:\n        last = val[-1]\n        val[-1] = 'value'\n        with pytest.raises(ValueError):\n            deviation_to_csv(output, md, inc, azi)\n        val[-1] = last", "framework": "pytest"}
{"code": "def position_to_csv(fname, depth, northing, easting, fmt='%.3f', delimiter=',', header='easting,northing,depth', **kwargs):\n    \"\"\"Write a log to a comma-separated values (csv) file.\n\n    Parameters\n    ----------\n    fname : str or file handle\n        file path or object the CSV will be written to.\n    depth : array-like,\n        true vertical depth (tvd) or\n        true vertical depth subsea (tvdss)\n    northing : array-like,\n        distance north of reference point\n    easting : array-like,\n        distance east of reference point,\n    fmt : str\n        this is the fmt argument to numpy.savetxt, see:\n        https://numpy.org/doc/stable/reference/generated/numpy.savetxt.html\n    delimiter : str\n        String or character separating columns.\n    header : str\n        String that will be written at the beginning of the file.\n        Beware if changing the header that it does not change the order in\n        which the data are written, which remains: `easting`,`northing`,`depth`.\n\n    Other Parameters\n    ----------------\n    **kwargs : All other keyword arguments are passed to `np.savetxt`\n\n    Notes\n    -----\n    This function is totally unit unaware, the user is responsible\n    to handle units.\n\n    Caution: position_to_csv uses Python write mode set to the default: \u2018w\u2019\n    therefore existing files will be overwritten.\n    \"\"\"\n    depth, northing, easting = checkarrays_tvd(depth, northing, easting)\n    a = np.asarray([easting, northing, depth])\n    np.savetxt(fname, a, fmt=fmt, delimiter=delimiter, header=header, **kwargs)\n    return None\ndef deviation_to_csv(fname, md, inc, azi, fmt='%.3f', delimiter=',', header='md,inc,azi', **kwargs): ...\ndef position_to_csv(fname, depth, northing, easting, fmt='%.3f', delimiter=',', header='easting,northing,depth', **kwargs): ...\n", "test": "def test_position_not_floats_throws():\n    output = io.StringIO()\n    tvd, northing, easting = (_tvd.copy(), _northing.copy(), _easting.copy())\n    for val in [tvd, northing, easting]:\n        last = val[-1]\n        val[-1] = 'value'\n        with pytest.raises(ValueError):\n            position_to_csv(output, tvd, northing, easting)\n        val[-1] = last", "framework": "pytest"}
{"code": "def deviation_to_csv(fname, md, inc, azi, fmt='%.3f', delimiter=',', header='md,inc,azi', **kwargs):\n    \"\"\"Write a log to a comma-separated values (csv) file.\n\n    Parameters\n    ----------\n    fname : str or file handle\n        file path or object the CSV will be written to.\n    md : array-like,\n        measured depth\n    inc : array-like,\n        inclination from vertical\n    azi : array-like,\n        azimuth from north\n    fmt : str\n        this is the fmt argument to numpy.savetxt, see:\n        https://numpy.org/doc/stable/reference/generated/numpy.savetxt.html\n    delimiter : str\n        String or character separating columns.\n    header : str\n        String that will be written at the beginning of the file.\n        Beware if changing the header that it does not change the order in\n        which the data are written, which remains: `md`,`inc`,`azi`.\n\n    Other Parameters\n    ----------------\n    **kwargs : All other keyword arguments are passed to `np.savetxt`\n\n    Notes\n    -----\n    This function is totally unit unaware, the user is responsible\n    to handle units.\n\n    Caution: deviation_to_csv uses Python write mode set to the default: \u2018w\u2019\n    therefore existing files will be overwritten.\n    \"\"\"\n    md, inc, azi = checkarrays(md, inc, azi)\n    a = np.asarray([md, inc, azi])\n    np.savetxt(fname, a, fmt=fmt, delimiter=delimiter, header=header, **kwargs)\n    return None\ndef deviation_to_csv(fname, md, inc, azi, fmt='%.3f', delimiter=',', header='md,inc,azi', **kwargs): ...\ndef position_to_csv(fname, depth, northing, easting, fmt='%.3f', delimiter=',', header='easting,northing,depth', **kwargs): ...\n", "test": "def test_deviation_nan_values_throws():\n    output = io.StringIO()\n    md, inc, azi = (_md.copy(), _inc.copy(), _azi.copy())\n    for val in [md, inc, azi]:\n        last = val[-1]\n        val[-1] = np.nan\n        with pytest.raises(ValueError):\n            deviation_to_csv(output, md, inc, azi)\n        val[-1] = last", "framework": "pytest"}
{"code": "def position_to_csv(fname, depth, northing, easting, fmt='%.3f', delimiter=',', header='easting,northing,depth', **kwargs):\n    \"\"\"Write a log to a comma-separated values (csv) file.\n\n    Parameters\n    ----------\n    fname : str or file handle\n        file path or object the CSV will be written to.\n    depth : array-like,\n        true vertical depth (tvd) or\n        true vertical depth subsea (tvdss)\n    northing : array-like,\n        distance north of reference point\n    easting : array-like,\n        distance east of reference point,\n    fmt : str\n        this is the fmt argument to numpy.savetxt, see:\n        https://numpy.org/doc/stable/reference/generated/numpy.savetxt.html\n    delimiter : str\n        String or character separating columns.\n    header : str\n        String that will be written at the beginning of the file.\n        Beware if changing the header that it does not change the order in\n        which the data are written, which remains: `easting`,`northing`,`depth`.\n\n    Other Parameters\n    ----------------\n    **kwargs : All other keyword arguments are passed to `np.savetxt`\n\n    Notes\n    -----\n    This function is totally unit unaware, the user is responsible\n    to handle units.\n\n    Caution: position_to_csv uses Python write mode set to the default: \u2018w\u2019\n    therefore existing files will be overwritten.\n    \"\"\"\n    depth, northing, easting = checkarrays_tvd(depth, northing, easting)\n    a = np.asarray([easting, northing, depth])\n    np.savetxt(fname, a, fmt=fmt, delimiter=delimiter, header=header, **kwargs)\n    return None\ndef deviation_to_csv(fname, md, inc, azi, fmt='%.3f', delimiter=',', header='md,inc,azi', **kwargs): ...\ndef position_to_csv(fname, depth, northing, easting, fmt='%.3f', delimiter=',', header='easting,northing,depth', **kwargs): ...\n", "test": "def test_position_nan_values_throws():\n    output = io.StringIO()\n    tvd, northing, easting = (_tvd.copy(), _northing.copy(), _easting.copy())\n    for val in [tvd, northing, easting]:\n        last = val[-1]\n        val[-1] = np.nan\n        with pytest.raises(ValueError):\n            position_to_csv(output, tvd, northing, easting)\n        val[-1] = last", "framework": "pytest"}
{"code": "class Genome():\n    def size(self):\n        \"\"\"\n            Complexity size: (n_hidden_nodes, enabled_links)\n            Adapted from: https://github.com/CodeReclaimers/neat-python, accessed May 2016\n            \"\"\"\n        hid = len(self.hidden_genes)\n        enabled_links = sum([1 for gene in self.link_genes if gene.enabled])\n        return (hid, enabled_links)\n    \n    def __init__(self, config, *, node_genes=None, link_genes=None): ...\n    def distance(self, other): ...\n    def node_genes(self): ...\n    def get_link_by_indices(self, src, sink): ...\n    def get_node_by_index(self, idx): ...\n    def _random_genome(self, n_inputs, n_outputs): ...\n    def _parse_node_genes(self, node_genes): ...\n    def _has_duplicate_node_indices(self): ...\n    def _has_duplicate_links(self): ...\n    def _check_links_have_valid_nodes(self): ...\n    def _check_args(n_inputs, n_outputs, node_genes, link_genes): ...\n\n    self.fitness = 0\n    self.link_genes = []\n    self.input_genes = []\n    self.hidden_genes = []\n    self.output_genes = []\n    self.config = config\n    self.n_links = len(self.link_genes)\n", "test": "def test_simple_size(self):\n    sz = self.genome.size()\n    assert sz == (0, 2), 'Size should be (0,2), is (%i, %i)' % (sz[0], sz[1])", "framework": "unittest"}
{"code": "class EztUnitTest(unittest.TestCase):\n    def _runTemplate(self, template, data, fmt=ezt.FORMAT_RAW):\n        if PY3 and isinstance(template, bytes):\n            template = template.decode('utf-8')\n        t = ezt.Template()\n        t.parse(template, base_format=fmt)\n        o = StringIO()\n        t.generate(o, data)\n        return o.getvalue()\n    \n    def _runTemplateFile(self, path, data): ...\n    def testSimpleReplacement(self): ...\n    def testSimpleReplacementUtf8Encoded(self): ...\n    def testSimpleReplacementUnicode(self): ...\n    def testSimpleReplacementStrTemplateAndUnicodeVariable(self): ...\n    def testSimpleReplacementUnicodeTemplateAndStrVariable(self): ...\n    def testLiteral(self): ...\n    def testLiteralUtf8Encoded(self): ...\n    def testLiteralUnicode(self): ...\n    def testAttributes(self): ...\n    def testFor(self): ...\n    def testIsAny(self): ...\n    def testIfIndex(self): ...\n    def testIsVarLiteral(self): ...\n    def testIsLiteralVar(self): ...\n    def testIsVarVar(self): ...\n    def testIsLiteralLiteral(self): ...\n    def testSubst(self): ...\n    def testSubstVarFormat(self): ...\n    def testFormatNotLiteral(self): ...\n    def testInclude(self): ...\n    def testIncludeNonLiteral(self): ...\n    def testInsert(self): ...\n    def testInsertNonLiteral(self): ...\n    def testDefineSimple(self): ...\n    def testDefineUnicode(self): ...\n    def testExceptionOnMissingVar(self): ...\n    def testReplacementEscapeHTML(self): ...\n    def testReplacementEscapeJS(self): ...\n    def testReplacementEscapeURL(self): ...\n    def testFormat(self): ...\n    def testFormatNested(self): ...\n    def testFormattedSubst(self): ...\n    def testFormattedSubstUnicode(self): ...\n    def testFormattedSubstVarFmt(self): ...\n    def testDoubleEndException(self): ...\n    def testForOnNonSequence(self): ...\n", "test": "def testDefineSimple(self):\n    d = self._runTemplate('[define RED]blue[end]RED = [RED]', {})\n    self.assertEqual('RED = blue', d)", "framework": "unittest"}
{"code": "def make_current(new):\n    \"\"\"Sets new active context. Returns previous one.\"\"\"\n    if not isinstance(new, (type(None), Context)):\n        raise TypeError('Argument of make_current() must be Context or None')\n    old = current()\n    current.context = new\n    return old\ndef current(): ...\ndef make_current(new): ...\n", "test": "def test_make_current(self):\n    \"\"\"Check if make_current() accepts context.\"\"\"\n    context = Context()\n    make_current(context)\n    self.assertTrue(current() == context)", "framework": "unittest"}
{"code": "def make_current(new):\n    \"\"\"Sets new active context. Returns previous one.\"\"\"\n    if not isinstance(new, (type(None), Context)):\n        raise TypeError('Argument of make_current() must be Context or None')\n    old = current()\n    current.context = new\n    return old\ndef current(): ...\ndef make_current(new): ...\n", "test": "def test_make_current_none(self):\n    \"\"\"Check if make_current() accepts None.\"\"\"\n    make_current(None)\n    self.assertTrue(current() == None)", "framework": "unittest"}
{"code": "def make_current(new):\n    \"\"\"Sets new active context. Returns previous one.\"\"\"\n    if not isinstance(new, (type(None), Context)):\n        raise TypeError('Argument of make_current() must be Context or None')\n    old = current()\n    current.context = new\n    return old\ndef current(): ...\ndef make_current(new): ...\n", "test": "def test_make_current_ret(self):\n    \"\"\"Check if make_current() returns previous context.\"\"\"\n    context1 = Context()\n    context2 = Context()\n    make_current(context1)\n    old = make_current(context2)\n    self.assertTrue(old == context1)", "framework": "unittest"}
{"code": "def make_current(new):\n    \"\"\"Sets new active context. Returns previous one.\"\"\"\n    if not isinstance(new, (type(None), Context)):\n        raise TypeError('Argument of make_current() must be Context or None')\n    old = current()\n    current.context = new\n    return old\ndef current(): ...\ndef make_current(new): ...\n", "test": "def test_make_current_bad_type(self):\n    \"\"\"Check if make_current() rejects non-context.\"\"\"\n    with self.assertRaises(TypeError):\n        make_current(42)", "framework": "unittest"}
{"code": "class WebsiteInputTests(unittest.TestCase):\n    def helperTestFileInputCourseParams(self, testFile: pathlib.Path, expected: '(term: constant from Term, year: int, courseInputInfos: [CourseInputInfo])'):\n        actual = configfileinput.fileInputCourseParams(testFile)\n        self.assertEqual(actual[0], expected[0])\n        self.assertEqual(actual[1], expected[1])\n        self.assertEqual(len(actual[2]), len(expected[2]))\n        for i in range(len(actual)):\n            self.assertEqual(actual[2][i].dept, expected[2][i].dept)\n            self.assertEqual(actual[2][i].courseName, expected[2][i].courseName)\n            self.assertEqual(actual[2][i].courseCodes, expected[2][i].courseCodes)\n    \n    def test_getFileName(self): ...\n    def test_getTerm(self): ...\n    def test_getDept(self): ...\n    def test_getCourseName(self): ...\n    def test_getCourseCodes(self): ...\n    def test_fileInputCourseParams(self): ...\n", "test": "def test_fileInputCourseParams(self):\n    \"\"\"\n        configfileinput.fileInputCourseParams should return correct values.\n        In particular, tests if returns correct course codes.\n        \"\"\"\n    self.helperTestFileInputCourseParams(pathlib.Path('unit_test_files/unit_test_web_input_1.txt'), (Term.WINTER, 2016, [CourseInputInfo('I&C SCI', 'ICS 32', '36600-36623'), CourseInputInfo('HUMAN', 'HUMAN 1B', '28100-28126'), CourseInputInfo('I&C SCI', 'ICS 6B', '49100-49130')]))\n    self.helperTestFileInputCourseParams(pathlib.Path('unit_test_files/unit_test_web_input_3.txt'), (Term.WINTER, 2016, [CourseInputInfo('I&C SCI', 'ICS 32', ''), CourseInputInfo('HUMAN', 'HUMAN 1B', '28100-28126'), CourseInputInfo('I&C SCI', 'ICS 6B', '49100-49130')]))\n    self.helperTestFileInputCourseParams(pathlib.Path('unit_test_files/unit_test_web_input_4.txt'), (Term.WINTER, 2016, [CourseInputInfo('I&C SCI', 'ICS 32', ''), CourseInputInfo('HUMAN', 'HUMAN 1B', '28100-28126'), CourseInputInfo('I&C SCI', 'ICS 6B', '')]))\n    self.helperTestFileInputCourseParams(pathlib.Path('unit_test_files/unit_test_web_input_5.txt'), (Term.WINTER, 2016, [CourseInputInfo('I&C SCI', 'ICS 32', ''), CourseInputInfo('HUMAN', 'HUMAN 1B', '28100-28126'), CourseInputInfo('I&C SCI', 'ICS 6B', '')]))\n    self.helperTestFileInputCourseParams(pathlib.Path('unit_test_files/unit_test_web_input_7.txt'), (Term.WINTER, 2016, [CourseInputInfo('I&C SCI', 'ICS 32', ''), CourseInputInfo('HUMAN', 'HUMAN 1B', ''), CourseInputInfo('I&C SCI', 'ICS 6B', '')]))", "framework": "unittest"}
{"code": "def get_drivers(year=None, race=None):\n    \"\"\"\n    Queries the API to obtain the list of drivers in a pandas dataframe format.\n    By default, this function returns the list of all drivers who have ever driven in F1.\n    If the year parameter is specified, this function returns the list of all drivers who drove in F1 in that year.\n    If the year and race parameters are specified, this function returns the list of all drivers who drove in F1 for a particular race.\n\n    Parameters\n    ----------\n    year: int\n        An optional parameter that specifies the year to be queried.\n    race: int\n        An optional parameter that specifies the round of a year to be queried.\n\n    Returns\n    -------\n    pandas.DataFrame\n\n    Index:\n        RangeIndex\n\n    Columns:\n        driverId: str\n        permanentNumber: int\n        code: str\n        url: str\n        givenName: str\n        familyName: str\n        dateOfBirth: str\n        nationality: str\n\n    Example\n    -------\n    >>> pyergast.get_drivers(2016)\n               driverId permanentNumber code  ...  familyName dateOfBirth nationality\n    0            alonso              14  ALO  ...      Alonso  1981-07-29     Spanish\n    1            bottas              77  BOT  ...      Bottas  1989-08-28     Finnish\n    2            button              22  BUT  ...      Button  1980-01-19     British\n    3          ericsson               9  ERI  ...    Ericsson  1990-09-02     Swedish\n    4          grosjean               8  GRO  ...    Grosjean  1986-04-17      French\n    5         gutierrez              21  GUT  ...   Guti\u00e9rrez  1991-08-05     Mexican\n    6          hamilton              44  HAM  ...    Hamilton  1985-01-07     British\n    7          haryanto              88  HAR  ...    Haryanto  1993-01-22  Indonesian\n    8        hulkenberg              27  HUL  ...  H\u00fclkenberg  1987-08-19      German\n    9             kvyat              26  KVY  ...       Kvyat  1994-04-26     Russian\n    10  kevin_magnussen              20  MAG  ...   Magnussen  1992-10-05      Danish\n    11            massa              19  MAS  ...       Massa  1981-04-25   Brazilian\n    12             nasr              12  NAS  ...        Nasr  1992-08-21   Brazilian\n    13             ocon              31  OCO  ...        Ocon  1996-09-17      French\n    14    jolyon_palmer              30  PAL  ...      Palmer  1991-01-20     British\n    15            perez              11  PER  ...       P\u00e9rez  1990-01-26     Mexican\n    16        raikkonen               7  RAI  ...   R\u00e4ikk\u00f6nen  1979-10-17     Finnish\n    17        ricciardo               3  RIC  ...   Ricciardo  1989-07-01  Australian\n    18          rosberg               6  ROS  ...     Rosberg  1985-06-27      German\n    19            sainz              55  SAI  ...       Sainz  1994-09-01     Spanish\n    20        vandoorne               2  VAN  ...   Vandoorne  1992-03-26     Belgian\n    21   max_verstappen              33  VER  ...  Verstappen  1997-09-30       Dutch\n    22           vettel               5  VET  ...      Vettel  1987-07-03      German\n    23         wehrlein              94  WEH  ...    Wehrlein  1994-10-18      German\n\n    [24 rows x 8 columns]\n    \"\"\"\n    if year and race:\n        url = 'http://ergast.com/api/f1/{}/drivers.json?limit=1000'.format(year, race)\n    elif year:\n        url = 'http://ergast.com/api/f1/{}/drivers.json?limit=1000'.format(year, race)\n    else:\n        url = 'http://ergast.com/api/f1/drivers.json?limit=1000'\n    r = requests.get(url)\n    assert r.status_code == 200, 'Cannot connect to Ergast API'\n    drivers = r.json()\n    result = pd.DataFrame(drivers['MRData']['DriverTable']['Drivers'])\n    return result\ndef get_drivers(year=None, race=None): ...\ndef get_constructors(year=None, race=None): ...\ndef get_circuits(year=None, race=None): ...\ndef find_driverid(firstname, lastname): ...\ndef find_constructorid(name): ...\ndef find_circuitid(circuit): ...\ndef get_race_result(year=None, race=None): ...\ndef get_qualifying_result(year=None, race=None): ...\ndef get_schedule(year=None): ...\ndef driver_standings(year=None, race=None): ...\ndef constructor_standings(year=None, race=None): ...\ndef query_driver(driverid): ...\ndef query_constructor(constructorid): ...\ndef unpack_lists(driver): ...\n", "test": "def test_get_drivers():\n    expected = 850\n    actual = pyergast.get_drivers()['driverId'].count()\n    assert expected == actual, 'Should be true (850 drivers in total)'", "framework": "pytest"}
{"code": "def get_constructors(year=None, race=None):\n    \"\"\"\n    Queries the API to obtain the list of constructors in a pandas dataframe format.\n    By default, this function returns the list of all constructors who have ever driven in F1.\n    If the year parameter is specified, this function returns the list of all constructors who participated F1 in that year.\n    If the year and race parameters are specified, this function returns the list of all constructors for a particular race.\n\n    Parameters\n    ----------\n    year: int\n        An optional parameter that specifies the year to be queried.\n    race: int\n        An optional parameter that specifies the round of a year to be queried.\n\n    Returns\n    -------\n    pandas.DataFrame\n\n    Index:\n        RangeIndex\n\n    Columns:\n        constructorId: str\n        url: str\n        name: str\n        nationality: str\n\n    Example\n    -------\n    >>> pyergast.get_constructors(year=2003, race=10)\n      constructorId                                                url      name nationality\n    0           bar  http://en.wikipedia.org/wiki/British_American_...       BAR     British\n    1       ferrari      http://en.wikipedia.org/wiki/Scuderia_Ferrari   Ferrari     Italian\n    2        jaguar         http://en.wikipedia.org/wiki/Jaguar_Racing    Jaguar     British\n    3        jordan     http://en.wikipedia.org/wiki/Jordan_Grand_Prix    Jordan       Irish\n    4       mclaren               http://en.wikipedia.org/wiki/McLaren   McLaren     British\n    5       minardi               http://en.wikipedia.org/wiki/Minardi   Minardi     Italian\n    6       renault  http://en.wikipedia.org/wiki/Renault_in_Formul...   Renault      French\n    7        sauber                http://en.wikipedia.org/wiki/Sauber    Sauber       Swiss\n    8        toyota         http://en.wikipedia.org/wiki/Toyota_Racing    Toyota    Japanese\n    9      williams  http://en.wikipedia.org/wiki/Williams_Grand_Pr...  Williams     British\n    \"\"\"\n    if year and race:\n        url = 'http://ergast.com/api/f1/{}/constructors.json?limit=1000'.format(year, race)\n    elif year:\n        url = 'http://ergast.com/api/f1/{}/constructors.json?limit=1000'.format(year, race)\n    else:\n        url = 'http://ergast.com/api/f1/constructors.json?limit=1000'\n    r = requests.get(url)\n    assert r.status_code == 200, 'Cannot connect to Ergast API. Check your inputs.'\n    constructors = r.json()\n    result = pd.DataFrame(constructors['MRData']['ConstructorTable']['Constructors'])\n    return result\ndef get_drivers(year=None, race=None): ...\ndef get_constructors(year=None, race=None): ...\ndef get_circuits(year=None, race=None): ...\ndef find_driverid(firstname, lastname): ...\ndef find_constructorid(name): ...\ndef find_circuitid(circuit): ...\ndef get_race_result(year=None, race=None): ...\ndef get_qualifying_result(year=None, race=None): ...\ndef get_schedule(year=None): ...\ndef driver_standings(year=None, race=None): ...\ndef constructor_standings(year=None, race=None): ...\ndef query_driver(driverid): ...\ndef query_constructor(constructorid): ...\ndef unpack_lists(driver): ...\n", "test": "def test_get_constructors():\n    expected = 211\n    actual = pyergast.get_constructors()['constructorId'].count()\n    assert expected == actual, 'Should be true (11 constructors in total)'", "framework": "pytest"}
{"code": "def get_circuits(year=None, race=None):\n    \"\"\"\n    Queries the API to obtain the list of circuits in a pandas dataframe format.\n    By default, this function returns the list of all circuits ever used in F1.\n    If the year parameter is specified, this function returns the list of all circuits used in F1 in that year.\n    If the year and race parameters are specified, this function returns the information of the circuit that hosted the specified race in specified year.\n\n    Parameters\n    ----------\n    year: int\n        An optional parameter that specifies the year to be queried.\n    race: int\n        An optional parameter that specifies the round of a year to be queried.\n\n    Returns\n    -------\n    pandas.DataFrame\n\n    Index:\n        RangeIndex\n\n    Columns:\n        circuitId: str\n        url: str\n        circuitName: str\n        Latitude: int\n        Longtitude: int\n        Locality: str\n        Country: str\n\n    Example\n    -------\n    >>> pyergast.get_circuits(year=1985, race=3)\n             circuitId                                                url  ...        Locality       Country\n    0         adelaide  http://en.wikipedia.org/wiki/Adelaide_Street_C...  ...        Adelaide     Australia\n    1     brands_hatch          http://en.wikipedia.org/wiki/Brands_Hatch  ...            Kent            UK\n    2          detroit  http://en.wikipedia.org/wiki/Detroit_street_ci...  ...         Detroit           USA\n    3          estoril  http://en.wikipedia.org/wiki/Aut%C3%B3dromo_do...  ...         Estoril      Portugal\n    4            imola  http://en.wikipedia.org/wiki/Autodromo_Enzo_e_...  ...           Imola         Italy\n    5      jacarepagua  http://en.wikipedia.org/wiki/Aut%C3%B3dromo_In...  ...  Rio de Janeiro        Brazil\n    6          kyalami               http://en.wikipedia.org/wiki/Kyalami  ...         Midrand  South Africa\n    7           monaco     http://en.wikipedia.org/wiki/Circuit_de_Monaco  ...     Monte-Carlo        Monaco\n    8            monza  http://en.wikipedia.org/wiki/Autodromo_Naziona...  ...           Monza         Italy\n    9      nurburgring      http://en.wikipedia.org/wiki/N%C3%BCrburgring  ...         N\u00fcrburg       Germany\n    10  osterreichring               http://en.wikipedia.org/wiki/A1-Ring  ...       Spielburg       Austria\n    11          ricard   http://en.wikipedia.org/wiki/Paul_Ricard_Circuit  ...    Le Castellet        France\n    12     silverstone   http://en.wikipedia.org/wiki/Silverstone_Circuit  ...     Silverstone            UK\n    13             spa  http://en.wikipedia.org/wiki/Circuit_de_Spa-Fr...  ...             Spa       Belgium\n    14      villeneuve  http://en.wikipedia.org/wiki/Circuit_Gilles_Vi...  ...        Montreal        Canada\n    15       zandvoort     http://en.wikipedia.org/wiki/Circuit_Zandvoort  ...       Zandvoort   Netherlands\n\n    [16 rows x 7 columns]\n    \"\"\"\n    if year and race:\n        url = 'http://ergast.com/api/f1/{}/circuits.json?limit=1000'.format(year, race)\n    elif year:\n        url = 'http://ergast.com/api/f1/{}/circuits.json?limit=1000'.format(year, race)\n    else:\n        url = 'http://ergast.com/api/f1/circuits.json?limit=1000'\n    r = requests.get(url)\n    assert r.status_code == 200, 'Cannot connect to Ergast API. Check your inputs.'\n    circuits = r.json()\n    result = pd.DataFrame(circuits['MRData']['CircuitTable']['Circuits'])\n    geo = result['Location']\n    latitude, longtitude, locality, country = ([] for i in range(4))\n    for track in geo:\n        latitude.append(track['lat'])\n        longtitude.append(track['long'])\n        locality.append(track['locality'])\n        country.append(track['country'])\n    result['Latitude'] = latitude\n    result['Longtitude'] = longtitude\n    result['Locality'] = locality\n    result['Country'] = country\n    result = result.drop('Location', axis=1)\n    return result\ndef get_drivers(year=None, race=None): ...\ndef get_constructors(year=None, race=None): ...\ndef get_circuits(year=None, race=None): ...\ndef find_driverid(firstname, lastname): ...\ndef find_constructorid(name): ...\ndef find_circuitid(circuit): ...\ndef get_race_result(year=None, race=None): ...\ndef get_qualifying_result(year=None, race=None): ...\ndef get_schedule(year=None): ...\ndef driver_standings(year=None, race=None): ...\ndef constructor_standings(year=None, race=None): ...\ndef query_driver(driverid): ...\ndef query_constructor(constructorid): ...\ndef unpack_lists(driver): ...\n", "test": "def test_get_circuits():\n    expected = 77\n    actual = pyergast.get_circuits()['circuitId'].count()\n    assert expected == actual, 'Should be true (76 circuits in total)'", "framework": "pytest"}
{"code": "def find_driverid(firstname, lastname):\n    \"\"\"\n    Searches the list of all drivers to find ones that are the same or similar to the input.\n\n    Parameters\n    ----------\n    firstname: str\n        The first name of the driver\n    lastname: str\n        The last name of the driver\n\n    Returns\n    -------\n    pandas.DataFrame\n\n    Index:\n        RangeIndex\n\n    Columns:\n        driverId: str\n        permanentNumber: int\n        code: str\n        url: str\n        givenName: str\n        familyName: str\n        dateOfBirth: str\n        nationality: str\n\n    Example\n    -------\n    >>> pyergast.find_driverid('peter', 'collins')\n             driverId                                                url givenName  ... nationality permanentNumber code\n    167       collins  http://en.wikipedia.org/wiki/Peter_Collins_(ra...     Peter  ...     British             NaN  NaN\n    595        peters  http://en.wikipedia.org/wiki/Josef_Peters_(dri...     Josef  ...      German             NaN  NaN\n    596      peterson       http://en.wikipedia.org/wiki/Ronnie_Peterson    Ronnie  ...     Swedish             NaN  NaN\n    809  peter_walker  http://en.wikipedia.org/wiki/Peter_Walker_(dri...     Peter  ...     British             NaN  NaN\n\n    [4 rows x 8 columns]\n    \"\"\"\n    dfDrivers = get_drivers()\n    result = dfDrivers[dfDrivers['driverId'].str.contains(firstname.lower()) | dfDrivers['driverId'].str.contains(lastname.lower())]\n    return result\ndef get_drivers(year=None, race=None): ...\ndef get_constructors(year=None, race=None): ...\ndef get_circuits(year=None, race=None): ...\ndef find_driverid(firstname, lastname): ...\ndef find_constructorid(name): ...\ndef find_circuitid(circuit): ...\ndef get_race_result(year=None, race=None): ...\ndef get_qualifying_result(year=None, race=None): ...\ndef get_schedule(year=None): ...\ndef driver_standings(year=None, race=None): ...\ndef constructor_standings(year=None, race=None): ...\ndef query_driver(driverid): ...\ndef query_constructor(constructorid): ...\ndef unpack_lists(driver): ...\n", "test": "def test_find_driverid():\n    expected = 1\n    actual = pyergast.find_driverid('Kimi', 'Raikkonen').shape[0]\n    assert expected == actual, 'There should 1 be result'", "framework": "pytest"}
{"code": "def find_constructorid(name):\n    \"\"\"\n    Searches the list of all constructors to find ones that are the same or similar to the input.\n\n    Parameters\n    ----------\n    name: str\n        The name of the constructor\n\n    Returns\n    -------\n    pandas.DataFrame\n\n    Index:\n        RangeIndex\n\n    Columns:\n        constructorId: str\n        url: str\n        name: str\n        nationality: str\n\n    Example\n    -------\n    >>> pyergast.find_constructorid('lotus')\n          constructorId                                        url                       name nationality\n    111    lotus_racing  http://en.wikipedia.org/wiki/Lotus_Racing                      Lotus   Malaysian\n    112        lotus_f1      http://en.wikipedia.org/wiki/Lotus_F1                   Lotus F1     British\n    113  lotus-borgward    http://en.wikipedia.org/wiki/Team_Lotus             Lotus-Borgward     British\n    114       lotus-brm    http://en.wikipedia.org/wiki/Team_Lotus                  Lotus-BRM     British\n    115    lotus-climax    http://en.wikipedia.org/wiki/Team_Lotus               Lotus-Climax     British\n    116      lotus-ford    http://en.wikipedia.org/wiki/Team_Lotus                 Lotus-Ford     British\n    117  lotus-maserati    http://en.wikipedia.org/wiki/Team_Lotus             Lotus-Maserati     British\n    118        lotus-pw    http://en.wikipedia.org/wiki/Team_Lotus  Lotus-Pratt &amp; Whitney     British\n    191      team_lotus    http://en.wikipedia.org/wiki/Team_Lotus                 Team Lotus     British\n    \"\"\"\n    dfConstructors = get_constructors()\n    result = dfConstructors[dfConstructors['constructorId'].str.contains(name.lower())]\n    return result\ndef get_drivers(year=None, race=None): ...\ndef get_constructors(year=None, race=None): ...\ndef get_circuits(year=None, race=None): ...\ndef find_driverid(firstname, lastname): ...\ndef find_constructorid(name): ...\ndef find_circuitid(circuit): ...\ndef get_race_result(year=None, race=None): ...\ndef get_qualifying_result(year=None, race=None): ...\ndef get_schedule(year=None): ...\ndef driver_standings(year=None, race=None): ...\ndef constructor_standings(year=None, race=None): ...\ndef query_driver(driverid): ...\ndef query_constructor(constructorid): ...\ndef unpack_lists(driver): ...\n", "test": "def test_find_constructorid():\n    expected = 1\n    actual = pyergast.find_constructorid('HAAS').shape[0]\n    assert expected == actual, 'There should 1 be result'", "framework": "pytest"}
{"code": "def find_circuitid(circuit):\n    \"\"\"\n    Searches the list of all the circuits that are similar to the input\n\n    Parameters\n    ----------\n    circuit: str\n        The name of the circuit. Actual circuit name, locality, or country are all accepted.\n\n    Returns\n    -------\n    pandas.DataFrame\n\n    Index:\n        RangeIndex\n\n    Columns:\n        circuitId: str\n        url: str\n        circuitName: str\n        Latitude: int\n        Longtitude: int\n        Locality: str\n        Country: str\n\n    Example\n    -------\n    >>> pyergast.find_circuitid('brazil')\n          circuitId                                                url  ...        Locality Country\n    29   interlagos  http://en.wikipedia.org/wiki/Aut%C3%B3dromo_Jo...  ...       S\u00e3o Paulo  Brazil\n    31  jacarepagua  http://en.wikipedia.org/wiki/Aut%C3%B3dromo_In...  ...  Rio de Janeiro  Brazil\n\n    [2 rows x 7 columns]\n    \"\"\"\n    dfCircuits = get_circuits()\n    result = dfCircuits[dfCircuits['circuitId'].str.lower().str.contains(circuit.lower()) | dfCircuits['circuitName'].str.lower().str.contains(circuit.lower()) | dfCircuits['Locality'].str.lower().str.contains(circuit.lower()) | dfCircuits['Country'].str.lower().str.contains(circuit.lower())]\n    return result\ndef get_drivers(year=None, race=None): ...\ndef get_constructors(year=None, race=None): ...\ndef get_circuits(year=None, race=None): ...\ndef find_driverid(firstname, lastname): ...\ndef find_constructorid(name): ...\ndef find_circuitid(circuit): ...\ndef get_race_result(year=None, race=None): ...\ndef get_qualifying_result(year=None, race=None): ...\ndef get_schedule(year=None): ...\ndef driver_standings(year=None, race=None): ...\ndef constructor_standings(year=None, race=None): ...\ndef query_driver(driverid): ...\ndef query_constructor(constructorid): ...\ndef unpack_lists(driver): ...\n", "test": "def test_find_circuitid():\n    expected = (4, 7)\n    actual = pyergast.find_circuitid('Portugal').shape\n    assert expected == actual, 'Should have 4 rows and 7 columns'", "framework": "pytest"}
{"code": "def get_race_result(year=None, race=None):\n    \"\"\"\n    Queries the API to return race results in a pandas dataframe format.\n    By default this method returns the most recent result\n\n    Parameters\n    ----------\n    year: int\n        An optional parameter that specifies the year to be queried.\n    race: int\n        An optional parameter that specifies the round of a year to be queried.\n\n    Returns\n    -------\n    pandas.DataFrame\n\n    Index:\n        RangeIndex\n\n    Columns:\n        number: int\n        position: int\n        positionText: str\n        grid: int\n        points: int\n        driverID: str\n        driver: str\n        nationality: str\n        constructorID: str\n        constructor: str\n        laps: int\n        status: str\n        Time: dict\n\n    Example\n    -------\n    >>> pyergast.get_race_result()\n       number position positionText grid  ...   constructor laps        status                                          Time\n    0      33        1            1    1  ...      Red Bull   55      Finished  {'millis': '5788645', 'time': '1:36:28.645'}\n    1      77        2            2    2  ...      Mercedes   55      Finished      {'millis': '5804621', 'time': '+15.976'}\n    2      44        3            3    3  ...      Mercedes   55      Finished      {'millis': '5807060', 'time': '+18.415'}\n    3      23        4            4    5  ...      Red Bull   55      Finished      {'millis': '5808632', 'time': '+19.987'}\n    4       4        5            5    4  ...       McLaren   55      Finished    {'millis': '5849374', 'time': '+1:00.729'}\n    5      55        6            6    6  ...       McLaren   55      Finished    {'millis': '5854307', 'time': '+1:05.662'}\n    6       3        7            7   11  ...       Renault   55      Finished    {'millis': '5862393', 'time': '+1:13.748'}\n    7      10        8            8    9  ...    AlphaTauri   55      Finished    {'millis': '5878363', 'time': '+1:29.718'}\n    8      31        9            9   10  ...       Renault   55      Finished      {'millis': '5799996', 'time': '+11.351'}\n    9      18       10           10    8  ...  Racing Point   55      Finished       {'millis': '5790314', 'time': '+1.669'}\n    10     26       11           11    7  ...    AlphaTauri   54        +1 Lap                                           NaN\n    11      7       12           12   15  ...    Alfa Romeo   54        +1 Lap                                           NaN\n    12     16       13           13   12  ...       Ferrari   54        +1 Lap                                           NaN\n    13      5       14           14   13  ...       Ferrari   54        +1 Lap                                           NaN\n    14     63       15           15   16  ...      Williams   54        +1 Lap                                           NaN\n    15     99       16           16   14  ...    Alfa Romeo   54        +1 Lap                                           NaN\n    16      6       17           17   18  ...      Williams   54        +1 Lap                                           NaN\n    17     20       18           18   20  ...  Haas F1 Team   54        +1 Lap                                           NaN\n    18     51       19           19   17  ...  Haas F1 Team   53       +2 Laps                                           NaN\n    19     11       20            R   19  ...  Racing Point    8  Transmission                                           NaN\n\n    [20 rows x 13 columns]\n    \"\"\"\n    if year or race:\n        assert year and race, 'You must specify both a year and a race'\n        url = 'http://ergast.com/api/f1/{}/{}/results.json?limit=1000'.format(year, race)\n    else:\n        url = 'http://ergast.com/api/f1/current/last/results.json?limit=1000'\n    r = requests.get(url)\n    assert r.status_code == 200, 'Cannot connect to Ergast API. Check your inputs.'\n    race_result = r.json()\n    result_dict = race_result['MRData']['RaceTable']['Races'][0]['Results']\n    for driver in result_dict:\n        drive_dict = unpack_lists(driver)\n        driver_info = drive_dict[0]\n        constructor_info = drive_dict[1]\n        driver['driver'] = driver_info['givenName'] + ' ' + driver_info['familyName']\n        driver['driverID'] = driver_info['driverId']\n        driver['nationality'] = driver_info['nationality']\n        driver['constructor'] = constructor_info['name']\n        driver['constructorID'] = constructor_info['constructorId']\n    cols = ['number', 'position', 'positionText', 'grid', 'points', 'driverID', 'driver', 'nationality', 'constructorID', 'constructor', 'laps', 'status', 'Time']\n    return pd.DataFrame(result_dict)[cols]\ndef get_drivers(year=None, race=None): ...\ndef get_constructors(year=None, race=None): ...\ndef get_circuits(year=None, race=None): ...\ndef find_driverid(firstname, lastname): ...\ndef find_constructorid(name): ...\ndef find_circuitid(circuit): ...\ndef get_race_result(year=None, race=None): ...\ndef get_qualifying_result(year=None, race=None): ...\ndef get_schedule(year=None): ...\ndef driver_standings(year=None, race=None): ...\ndef constructor_standings(year=None, race=None): ...\ndef query_driver(driverid): ...\ndef query_constructor(constructorid): ...\ndef unpack_lists(driver): ...\n", "test": "def test_get_race_result():\n    expected = '44'\n    actual = pyergast.get_race_result(2014, 4)['number'][0]\n    assert expected == actual, 'Number 44 should have won'", "framework": "pytest"}
{"code": "def get_qualifying_result(year=None, race=None):\n    \"\"\"\n    Queries the API to return qualifying results in a pandas dataframe format.\n    By default this method returns the most recent result\n\n    Parameters\n    ----------\n    year: int\n        An optional parameter that specifies the year to be queried.\n    race: int\n        An optional parameter that specifies the round of a year to be queried.\n\n    Returns\n    -------\n    pandas.DataFrame\n\n    Index:\n        RangeIndex\n\n    Columns:\n        number: int\n        position: int\n        driverID: str\n        driver: str\n        nationality: str\n        constructorID: str\n        constructor: str\n        Q1: str\n        Q2: str\n        Q3: str\n\n    Example\n    -------\n    >>> pyergast.get_qualifying_result()\n       number position           driverID              driver  ...   constructor        Q1        Q2        Q3\n    0      33        1     max_verstappen      Max Verstappen  ...      Red Bull  1:35.993  1:35.641  1:35.246\n    1      77        2             bottas     Valtteri Bottas  ...      Mercedes  1:35.699  1:35.527  1:35.271\n    2      44        3           hamilton      Lewis Hamilton  ...      Mercedes  1:35.528  1:35.466  1:35.332\n    3       4        4             norris        Lando Norris  ...       McLaren  1:36.016  1:35.849  1:35.497\n    4      23        5              albon     Alexander Albon  ...      Red Bull  1:36.106  1:35.654  1:35.571\n    5      55        6              sainz        Carlos Sainz  ...       McLaren  1:36.517  1:36.192  1:35.815\n    6      26        7              kvyat        Daniil Kvyat  ...    AlphaTauri  1:36.459  1:36.214  1:35.963\n    7      18        8             stroll        Lance Stroll  ...  Racing Point  1:36.502  1:36.143  1:36.046\n    8      16        9            leclerc     Charles Leclerc  ...       Ferrari  1:35.881  1:35.932  1:36.065\n    9      10       10              gasly        Pierre Gasly  ...    AlphaTauri  1:36.545  1:36.282  1:36.242\n    10     31       11               ocon        Esteban Ocon  ...       Renault  1:36.783  1:36.359       NaN\n    11      3       12          ricciardo    Daniel Ricciardo  ...       Renault  1:36.704  1:36.406       NaN\n    12      5       13             vettel    Sebastian Vettel  ...       Ferrari  1:36.655  1:36.631       NaN\n    13     99       14         giovinazzi  Antonio Giovinazzi  ...    Alfa Romeo  1:37.075  1:38.248       NaN\n    14     11       15              perez        Sergio P\u00e9rez  ...  Racing Point  1:36.034       NaN       NaN\n    15      7       16          raikkonen      Kimi R\u00e4ikk\u00f6nen  ...    Alfa Romeo  1:37.555       NaN       NaN\n    16     20       17    kevin_magnussen     Kevin Magnussen  ...  Haas F1 Team  1:37.863       NaN       NaN\n    17     63       18            russell      George Russell  ...      Williams  1:38.045       NaN       NaN\n    18     51       19  pietro_fittipaldi   Pietro Fittipaldi  ...  Haas F1 Team  1:38.173       NaN       NaN\n    19      6       20             latifi     Nicholas Latifi  ...      Williams  1:38.443       NaN       NaN\n\n    [20 rows x 10 columns]\n    \"\"\"\n    if year and race:\n        assert year >= 1996, 'Qualifying data only available starting from 1996'\n        url = 'http://ergast.com/api/f1/{}/{}/qualifying.json?limit=1000'.format(year, race)\n    else:\n        url = 'http://ergast.com/api/f1/current/last/qualifying.json?limit=1000'\n    r = requests.get(url)\n    assert r.status_code == 200, 'Cannot connect to Ergast API. Check your inputs.'\n    race_result = r.json()\n    result_dict = race_result['MRData']['RaceTable']['Races'][0]['QualifyingResults']\n    for driver in result_dict:\n        drive_dict = unpack_lists(driver)\n        driver_info = drive_dict[0]\n        constructor_info = drive_dict[1]\n        driver['driver'] = driver_info['givenName'] + ' ' + driver_info['familyName']\n        driver['driverID'] = driver_info['driverId']\n        driver['nationality'] = driver_info['nationality']\n        driver['constructor'] = constructor_info['name']\n        driver['constructorID'] = constructor_info['constructorId']\n    cols = ['number', 'position', 'driverID', 'driver', 'nationality', 'constructorID', 'constructor', 'Q1']\n    if 'Q2' in result_dict[0].keys():\n        cols.append('Q2')\n    if 'Q3' in result_dict[0].keys():\n        cols.append('Q3')\n    return pd.DataFrame(result_dict)[cols]\ndef get_drivers(year=None, race=None): ...\ndef get_constructors(year=None, race=None): ...\ndef get_circuits(year=None, race=None): ...\ndef find_driverid(firstname, lastname): ...\ndef find_constructorid(name): ...\ndef find_circuitid(circuit): ...\ndef get_race_result(year=None, race=None): ...\ndef get_qualifying_result(year=None, race=None): ...\ndef get_schedule(year=None): ...\ndef driver_standings(year=None, race=None): ...\ndef constructor_standings(year=None, race=None): ...\ndef query_driver(driverid): ...\ndef query_constructor(constructorid): ...\ndef unpack_lists(driver): ...\n", "test": "def test_get_qualifying_result():\n    expected = '44'\n    actual = pyergast.get_qualifying_result(2014, 4)['number'][0]\n    assert expected == actual, 'Number 44 should have qualified first'", "framework": "pytest"}
{"code": "def get_qualifying_result(year=None, race=None):\n    \"\"\"\n    Queries the API to return qualifying results in a pandas dataframe format.\n    By default this method returns the most recent result\n\n    Parameters\n    ----------\n    year: int\n        An optional parameter that specifies the year to be queried.\n    race: int\n        An optional parameter that specifies the round of a year to be queried.\n\n    Returns\n    -------\n    pandas.DataFrame\n\n    Index:\n        RangeIndex\n\n    Columns:\n        number: int\n        position: int\n        driverID: str\n        driver: str\n        nationality: str\n        constructorID: str\n        constructor: str\n        Q1: str\n        Q2: str\n        Q3: str\n\n    Example\n    -------\n    >>> pyergast.get_qualifying_result()\n       number position           driverID              driver  ...   constructor        Q1        Q2        Q3\n    0      33        1     max_verstappen      Max Verstappen  ...      Red Bull  1:35.993  1:35.641  1:35.246\n    1      77        2             bottas     Valtteri Bottas  ...      Mercedes  1:35.699  1:35.527  1:35.271\n    2      44        3           hamilton      Lewis Hamilton  ...      Mercedes  1:35.528  1:35.466  1:35.332\n    3       4        4             norris        Lando Norris  ...       McLaren  1:36.016  1:35.849  1:35.497\n    4      23        5              albon     Alexander Albon  ...      Red Bull  1:36.106  1:35.654  1:35.571\n    5      55        6              sainz        Carlos Sainz  ...       McLaren  1:36.517  1:36.192  1:35.815\n    6      26        7              kvyat        Daniil Kvyat  ...    AlphaTauri  1:36.459  1:36.214  1:35.963\n    7      18        8             stroll        Lance Stroll  ...  Racing Point  1:36.502  1:36.143  1:36.046\n    8      16        9            leclerc     Charles Leclerc  ...       Ferrari  1:35.881  1:35.932  1:36.065\n    9      10       10              gasly        Pierre Gasly  ...    AlphaTauri  1:36.545  1:36.282  1:36.242\n    10     31       11               ocon        Esteban Ocon  ...       Renault  1:36.783  1:36.359       NaN\n    11      3       12          ricciardo    Daniel Ricciardo  ...       Renault  1:36.704  1:36.406       NaN\n    12      5       13             vettel    Sebastian Vettel  ...       Ferrari  1:36.655  1:36.631       NaN\n    13     99       14         giovinazzi  Antonio Giovinazzi  ...    Alfa Romeo  1:37.075  1:38.248       NaN\n    14     11       15              perez        Sergio P\u00e9rez  ...  Racing Point  1:36.034       NaN       NaN\n    15      7       16          raikkonen      Kimi R\u00e4ikk\u00f6nen  ...    Alfa Romeo  1:37.555       NaN       NaN\n    16     20       17    kevin_magnussen     Kevin Magnussen  ...  Haas F1 Team  1:37.863       NaN       NaN\n    17     63       18            russell      George Russell  ...      Williams  1:38.045       NaN       NaN\n    18     51       19  pietro_fittipaldi   Pietro Fittipaldi  ...  Haas F1 Team  1:38.173       NaN       NaN\n    19      6       20             latifi     Nicholas Latifi  ...      Williams  1:38.443       NaN       NaN\n\n    [20 rows x 10 columns]\n    \"\"\"\n    if year and race:\n        assert year >= 1996, 'Qualifying data only available starting from 1996'\n        url = 'http://ergast.com/api/f1/{}/{}/qualifying.json?limit=1000'.format(year, race)\n    else:\n        url = 'http://ergast.com/api/f1/current/last/qualifying.json?limit=1000'\n    r = requests.get(url)\n    assert r.status_code == 200, 'Cannot connect to Ergast API. Check your inputs.'\n    race_result = r.json()\n    result_dict = race_result['MRData']['RaceTable']['Races'][0]['QualifyingResults']\n    for driver in result_dict:\n        drive_dict = unpack_lists(driver)\n        driver_info = drive_dict[0]\n        constructor_info = drive_dict[1]\n        driver['driver'] = driver_info['givenName'] + ' ' + driver_info['familyName']\n        driver['driverID'] = driver_info['driverId']\n        driver['nationality'] = driver_info['nationality']\n        driver['constructor'] = constructor_info['name']\n        driver['constructorID'] = constructor_info['constructorId']\n    cols = ['number', 'position', 'driverID', 'driver', 'nationality', 'constructorID', 'constructor', 'Q1']\n    if 'Q2' in result_dict[0].keys():\n        cols.append('Q2')\n    if 'Q3' in result_dict[0].keys():\n        cols.append('Q3')\n    return pd.DataFrame(result_dict)[cols]\ndef get_drivers(year=None, race=None): ...\ndef get_constructors(year=None, race=None): ...\ndef get_circuits(year=None, race=None): ...\ndef find_driverid(firstname, lastname): ...\ndef find_constructorid(name): ...\ndef find_circuitid(circuit): ...\ndef get_race_result(year=None, race=None): ...\ndef get_qualifying_result(year=None, race=None): ...\ndef get_schedule(year=None): ...\ndef driver_standings(year=None, race=None): ...\ndef constructor_standings(year=None, race=None): ...\ndef query_driver(driverid): ...\ndef query_constructor(constructorid): ...\ndef unpack_lists(driver): ...\n", "test": "def test_qualifying_assert():\n    with pytest.raises(AssertionError):\n        pyergast.get_qualifying_result(1950, 1)", "framework": "pytest"}
{"code": "def get_schedule(year=None):\n    \"\"\"\n    Queries the API to return the schedule of a specified season. Defaults to most recent season.\n\n    Parameters\n    ----------\n    year: int\n        An optional parameter that specifies the year to be queried.\n\n    Returns\n    -------\n    pandas.DataFrame\n\n    Index:\n        RangeIndex\n\n    Columns:\n        season: int\n        round: int\n        url: str\n        raceName: str\n        date: str\n        circuitId: str\n        circuitName: str\n        locality: str\n        country: str\n\n    Example\n    -------\n    >>> pyergast.get_schedule(1957)\n      season round  ...      locality    country\n    0   1957     1  ...  Buenos Aires  Argentina\n    1   1957     2  ...   Monte-Carlo     Monaco\n    2   1957     3  ...  Indianapolis        USA\n    3   1957     4  ...         Rouen     France\n    4   1957     5  ...     Liverpool         UK\n    5   1957     6  ...       N\u00fcrburg    Germany\n    6   1957     7  ...       Pescara      Italy\n    7   1957     8  ...         Monza      Italy\n\n    [8 rows x 9 columns]\n    \"\"\"\n    if year:\n        url = 'http://ergast.com/api/f1/{}.json?limit=1000'.format(year)\n    else:\n        url = 'http://ergast.com/api/f1/current.json?limit=1000'\n    r = requests.get(url)\n    assert r.status_code == 200, 'Cannot connect to Ergast API. Check your inputs.'\n    schedule = r.json()['MRData']['RaceTable']['Races']\n    for race in schedule:\n        circuit = unpack_lists(race)[0]\n        race['circuitID'] = circuit['circuitId']\n        race['circuitName'] = circuit['circuitName']\n        race['locality'] = circuit['Location']['locality']\n        race['country'] = circuit['Location']['country']\n        del race['Circuit']\n    return pd.DataFrame(schedule)\ndef get_drivers(year=None, race=None): ...\ndef get_constructors(year=None, race=None): ...\ndef get_circuits(year=None, race=None): ...\ndef find_driverid(firstname, lastname): ...\ndef find_constructorid(name): ...\ndef find_circuitid(circuit): ...\ndef get_race_result(year=None, race=None): ...\ndef get_qualifying_result(year=None, race=None): ...\ndef get_schedule(year=None): ...\ndef driver_standings(year=None, race=None): ...\ndef constructor_standings(year=None, race=None): ...\ndef query_driver(driverid): ...\ndef query_constructor(constructorid): ...\ndef unpack_lists(driver): ...\n", "test": "def test_get_schedule():\n    expected = 17\n    actual = pyergast.get_schedule().shape[0]\n    assert expected == actual, 'There were 17 races in 2020'", "framework": "pytest"}
{"code": "def driver_standings(year=None, race=None):\n    \"\"\"\n    Fetch the driver standings after a specific race in a specific year. Defaults to latest standings\n\n    Parameters\n    ----------\n    year: int\n        An optional parameter that specifies the year to be queried.\n    race: int\n        An optional parameter that specifies the round of a year to be queried.\n\n    Returns\n    -------\n    pandas.DataFrame\n\n    Index:\n        RangeIndex\n\n    Columns:\n        position: int\n        positionText: str\n        points: int\n        wins: int\n        driverID: str\n        driver: str\n        nationality: str\n        constructorID: str\n        constructor: str\n\n    Example\n    -------\n    >>> pyergast.driver_standings(1974)\n       position positionText points wins            driverID              driver    nationality constructorID constructor\n    0         1            1     55    3  emerson_fittipaldi  Emerson Fittipaldi      Brazilian       mclaren     McLaren\n    1         2            2     52    1           regazzoni      Clay Regazzoni          Swiss       ferrari     Ferrari\n    2         3            3     45    2           scheckter      Jody Scheckter  South African       tyrrell     Tyrrell\n    3         4            4     38    2               lauda          Niki Lauda       Austrian       ferrari     Ferrari\n    4         5            5     35    3            peterson     Ronnie Peterson        Swedish    team_lotus  Team Lotus\n    ..      ...          ...    ...  ...                 ...                 ...            ...           ...         ...\n    57       58           58      0    0              purley        David Purley        British         token       Token\n    58       59           59      0    0             facetti       Carlo Facetti        Italian       brabham     Brabham\n    59       60           60      0    0            lombardi      Lella Lombardi        Italian       brabham     Brabham\n    60       61           61      0    0             perkins       Larry Perkins     Australian          amon        Amon\n    61       62           62      0    0           nicholson      John Nicholson  New Zealander        lyncar      Lyncar\n\n    [62 rows x 9 columns]\n    \"\"\"\n    if year and race:\n        url = 'http://ergast.com/api/f1/{}/{}/driverStandings.json?limit=1000'.format(year, race)\n    elif year:\n        url = 'http://ergast.com/api/f1/{}/driverStandings.json?limit=1000'.format(year, race)\n    else:\n        url = 'http://ergast.com/api/f1/current/driverStandings.json?limit=1000'\n    r = requests.get(url)\n    assert r.status_code == 200, 'Cannot connect to Ergast API. Check your inputs.'\n    driverStandings = r.json()['MRData']['StandingsTable']['StandingsLists'][0]['DriverStandings']\n    for driver in driverStandings:\n        driver['driverID'] = driver['Driver']['driverId']\n        driver['driver'] = driver['Driver']['givenName'] + ' ' + driver['Driver']['familyName']\n        driver['nationality'] = driver['Driver']['nationality']\n        driver['constructorID'] = driver['Constructors'][0]['constructorId']\n        driver['constructor'] = driver['Constructors'][0]['name']\n        del driver['Driver']\n        del driver['Constructors']\n    return pd.DataFrame(driverStandings)\ndef get_drivers(year=None, race=None): ...\ndef get_constructors(year=None, race=None): ...\ndef get_circuits(year=None, race=None): ...\ndef find_driverid(firstname, lastname): ...\ndef find_constructorid(name): ...\ndef find_circuitid(circuit): ...\ndef get_race_result(year=None, race=None): ...\ndef get_qualifying_result(year=None, race=None): ...\ndef get_schedule(year=None): ...\ndef driver_standings(year=None, race=None): ...\ndef constructor_standings(year=None, race=None): ...\ndef query_driver(driverid): ...\ndef query_constructor(constructorid): ...\ndef unpack_lists(driver): ...\n", "test": "def test_driver_standings():\n    expected = 81\n    actual = pyergast.driver_standings(1950).shape[0]\n    assert expected == actual, 'There were 81 drivers in 1950'", "framework": "pytest"}
{"code": "def constructor_standings(year=None, race=None):\n    \"\"\"\n    Fetch the constructor standings after a specific race in a specific year. Defaults to latest standings\n\n    Parameters\n    ----------\n    year: int\n        An optional parameter that specifies the year to be queried.\n    race: int\n        An optional parameter that specifies the round of a year to be queried.\n\n    Returns\n    -------\n    pandas.DataFrame\n\n    Index:\n        RangeIndex\n\n    Columns:\n        position: int\n        positionText: str\n        points: int\n        wins: int\n        constructorID: str\n        constructor: str\n        nationality: str\n\n    Example\n    -------\n    >>> pyergast.constructor_standings(1965)\n       position positionText points wins    constructorID             name    nationality\n    0         1            1     54    6     lotus-climax     Lotus-Climax        British\n    1         2            2     45    3              brm              BRM        British\n    2         3            3     27    0   brabham-climax   Brabham-Climax        British\n    3         4            4     26    0          ferrari          Ferrari        Italian\n    4         5            5     14    0    cooper-climax    Cooper-Climax        British\n    5         6            6     11    1            honda            Honda       Japanese\n    6         7            7      5    0      brabham-brm      Brabham-BRM        British\n    7         8            8      2    0        lotus-brm        Lotus-BRM        British\n    8         9            9      0    0     brabham-ford     Brabham-Ford        British\n    9        10           10      0    0             alfa       Alfa Romeo        Italian\n    10       11           11      0    0   lds-alfa_romeo   LDS-Alfa Romeo  South African\n    11       12           12      0    0      cooper-ford      Cooper-Ford        British\n    12       13           13      0    0       lds-climax       LDS-Climax  South African\n    13       14           14      0    0       lotus-ford       Lotus-Ford        British\n    14       15           15      0    0               re               RE      Rhodesian\n    15       16           16      0    0  cooper-maserati  Cooper-Maserati        British\n    \"\"\"\n    if year and race:\n        assert year >= 1958, 'Constructor standings only available starting 1958'\n        url = 'http://ergast.com/api/f1/{}/constructorStandings.json?limit=1000'.format(year, race)\n    elif year:\n        assert year >= 1958, 'Constructor standings only available starting 1958'\n        url = 'http://ergast.com/api/f1/{}/constructorStandings.json?limit=1000'.format(year, race)\n    else:\n        url = 'http://ergast.com/api/f1/current/constructorStandings.json?limit=1000'\n    r = requests.get(url)\n    assert r.status_code == 200, 'Cannot connect to Ergast API. Check your inputs.'\n    constructorStandings = r.json()['MRData']['StandingsTable']['StandingsLists'][0]['ConstructorStandings']\n    for constructor in constructorStandings:\n        constructor['constructorID'] = constructor['Constructor']['constructorId']\n        constructor['name'] = constructor['Constructor']['name']\n        constructor['nationality'] = constructor['Constructor']['nationality']\n        del constructor['Constructor']\n    return pd.DataFrame(constructorStandings)\ndef get_drivers(year=None, race=None): ...\ndef get_constructors(year=None, race=None): ...\ndef get_circuits(year=None, race=None): ...\ndef find_driverid(firstname, lastname): ...\ndef find_constructorid(name): ...\ndef find_circuitid(circuit): ...\ndef get_race_result(year=None, race=None): ...\ndef get_qualifying_result(year=None, race=None): ...\ndef get_schedule(year=None): ...\ndef driver_standings(year=None, race=None): ...\ndef constructor_standings(year=None, race=None): ...\ndef query_driver(driverid): ...\ndef query_constructor(constructorid): ...\ndef unpack_lists(driver): ...\n", "test": "def test_constructor_standings():\n    expected = 17\n    actual = pyergast.constructor_standings(1985).shape[0]\n    assert expected == actual, 'There were 17 constructors in 1950'", "framework": "pytest"}
{"code": "def query_driver(driverid):\n    \"\"\"\n    Fetches the driver's historical driver standings position\n\n    Parameters\n    ----------\n    driverid: str\n        A string representing the driver id of the driver. Use `find_driverid` method to obtain constructorid\n\n    Returns\n    -------\n    pandas.DataFrame\n\n    Index:\n        RangeIndex\n\n    Columns:\n        season: int\n        round: int\n        position: int\n        positionText: str\n        points: int\n        wins: int\n        driver: str\n        nationality: str\n        constructorID: str\n        constructor: str\n\n    Example\n    -------\n    >>> pyergast.query_driver('raikkonen')\n       season round position positionText points wins          driver nationality constructorID constructor\n    0    2001    17       10           10      9    0  Kimi R\u00e4ikk\u00f6nen     Finnish        sauber      Sauber\n    1    2002    17        6            6     24    0  Kimi R\u00e4ikk\u00f6nen     Finnish       mclaren     McLaren\n    2    2003    16        2            2     91    1  Kimi R\u00e4ikk\u00f6nen     Finnish       mclaren     McLaren\n    3    2004    18        7            7     45    1  Kimi R\u00e4ikk\u00f6nen     Finnish       mclaren     McLaren\n    4    2005    19        2            2    112    7  Kimi R\u00e4ikk\u00f6nen     Finnish       mclaren     McLaren\n    5    2006    18        5            5     65    0  Kimi R\u00e4ikk\u00f6nen     Finnish       mclaren     McLaren\n    6    2007    17        1            1    110    6  Kimi R\u00e4ikk\u00f6nen     Finnish       ferrari     Ferrari\n    7    2008    18        3            3     75    2  Kimi R\u00e4ikk\u00f6nen     Finnish       ferrari     Ferrari\n    8    2009    17        6            6     48    1  Kimi R\u00e4ikk\u00f6nen     Finnish       ferrari     Ferrari\n    9    2012    20        3            3    207    1  Kimi R\u00e4ikk\u00f6nen     Finnish      lotus_f1    Lotus F1\n    10   2013    19        5            5    183    1  Kimi R\u00e4ikk\u00f6nen     Finnish      lotus_f1    Lotus F1\n    11   2014    19       12           12     55    0  Kimi R\u00e4ikk\u00f6nen     Finnish       ferrari     Ferrari\n    12   2015    19        4            4    150    0  Kimi R\u00e4ikk\u00f6nen     Finnish       ferrari     Ferrari\n    13   2016    21        6            6    186    0  Kimi R\u00e4ikk\u00f6nen     Finnish       ferrari     Ferrari\n    14   2017    20        4            4    205    0  Kimi R\u00e4ikk\u00f6nen     Finnish       ferrari     Ferrari\n    15   2018    21        3            3    251    1  Kimi R\u00e4ikk\u00f6nen     Finnish       ferrari     Ferrari\n    16   2019    21       12           12     43    0  Kimi R\u00e4ikk\u00f6nen     Finnish          alfa  Alfa Romeo\n    17   2020    17       16           16      4    0  Kimi R\u00e4ikk\u00f6nen     Finnish          alfa  Alfa Romeo\n    \"\"\"\n    url = 'http://ergast.com/api/f1/drivers/{}/driverStandings.json?limit=1000'.format(driverid)\n    r = requests.get(url)\n    assert r.status_code == 200, 'Cannot connect to Ergast API. Check your inputs.'\n    seasons = r.json()['MRData']['StandingsTable']['StandingsLists']\n    for season in seasons:\n        for key, value in season['DriverStandings'][0].items():\n            season[key] = value\n        season['driver'] = season['Driver']['givenName'] + ' ' + season['Driver']['familyName']\n        season['nationality'] = season['Driver']['nationality']\n        season['constructorID'] = season['Constructors'][0]['constructorId']\n        season['constructor'] = season['Constructors'][0]['name']\n        del season['DriverStandings']\n        del season['Driver']\n        del season['Constructors']\n    return pd.DataFrame(seasons)\ndef get_drivers(year=None, race=None): ...\ndef get_constructors(year=None, race=None): ...\ndef get_circuits(year=None, race=None): ...\ndef find_driverid(firstname, lastname): ...\ndef find_constructorid(name): ...\ndef find_circuitid(circuit): ...\ndef get_race_result(year=None, race=None): ...\ndef get_qualifying_result(year=None, race=None): ...\ndef get_schedule(year=None): ...\ndef driver_standings(year=None, race=None): ...\ndef constructor_standings(year=None, race=None): ...\ndef query_driver(driverid): ...\ndef query_constructor(constructorid): ...\ndef unpack_lists(driver): ...\n", "test": "def test_query_driver():\n    expected = (1, 10)\n    actual = pyergast.query_driver('aitken').shape\n    assert expected == actual, 'Should be (1, 10)'", "framework": "pytest"}
{"code": "def query_constructor(constructorid):\n    \"\"\"\n    Fetches the consturctor's historical constructor standings position\n\n    Parameters\n    ----------\n    constructorid: str\n        A string representing the constructor id of the constructor. Use `find_constructorid` function to obtain constructorid\n\n    Returns\n    -------\n    pandas.DataFrame\n\n    Index:\n        RangeIndex\n\n    Columns:\n        season: int\n        round: int\n        position: int\n        positionText: str\n        points: int\n        wins: int\n        constructorID: str\n        constructor: str\n        nationality: str\n\n    Example\n    -------\n    >>> pyergast.query_constructor('alfa')\n       season round position positionText points wins constructorID constructor nationality\n    0    1963    10       16           16      0    0          alfa  Alfa Romeo     Italian\n    1    1965    10       10           10      0    0          alfa  Alfa Romeo     Italian\n    2    1979    15       16           16      0    0          alfa  Alfa Romeo     Italian\n    3    1980    14       11           11      4    0          alfa  Alfa Romeo     Italian\n    4    1981    15        9            9     10    0          alfa  Alfa Romeo     Italian\n    5    1982    16        9            9      7    0          alfa  Alfa Romeo     Italian\n    6    1983    15        6            6     18    0          alfa  Alfa Romeo     Italian\n    7    1984    16        8            8     11    0          alfa  Alfa Romeo     Italian\n    8    1985    16       12           12      0    0          alfa  Alfa Romeo     Italian\n    9    2019    21        8            8     57    0          alfa  Alfa Romeo     Italian\n    10   2020    17        8            8      8    0          alfa  Alfa Romeo     Italian\n    \"\"\"\n    url = 'http://ergast.com/api/f1/constructors/{}/constructorStandings.json?limit=1000'.format(constructorid)\n    r = requests.get(url)\n    assert r.status_code == 200, 'Cannot connect to Ergast API. Check your inputs.'\n    seasons = r.json()['MRData']['StandingsTable']['StandingsLists']\n    for season in seasons:\n        for key, value in season['ConstructorStandings'][0].items():\n            season[key] = value\n        season['constructorID'] = season['Constructor']['constructorId']\n        season['constructor'] = season['Constructor']['name']\n        season['nationality'] = season['Constructor']['nationality']\n        del season['Constructor']\n        del season['ConstructorStandings']\n    return pd.DataFrame(seasons)\ndef get_drivers(year=None, race=None): ...\ndef get_constructors(year=None, race=None): ...\ndef get_circuits(year=None, race=None): ...\ndef find_driverid(firstname, lastname): ...\ndef find_constructorid(name): ...\ndef find_circuitid(circuit): ...\ndef get_race_result(year=None, race=None): ...\ndef get_qualifying_result(year=None, race=None): ...\ndef get_schedule(year=None): ...\ndef driver_standings(year=None, race=None): ...\ndef constructor_standings(year=None, race=None): ...\ndef query_driver(driverid): ...\ndef query_constructor(constructorid): ...\ndef unpack_lists(driver): ...\n", "test": "def test_query_constructor():\n    expected = (63, 9)\n    actual = pyergast.query_constructor('ferrari').shape\n    assert expected == actual, 'Should be (63, 9)'", "framework": "pytest"}
{"code": "class realsense(camera):\n    def get_frame(self):\n        try:\n            self.color_image, self.depth_image = self.get_aligned_realsense_frames()\n            return True\n        except Exception as e:\n            print('realsense: failed to get color and depth frames ', e)\n            return False\n    \n    def __init__(self, device_id=0): ...\n    def get_aligned_realsense_frames(self): ...\n    def get_calibration(self): ...\n    def release(self): ...\n    def destroy(self): ...\n\n    self.pipeline = rs.pipeline()\n    self.config = rs.config()\n    self.profile = self.pipeline.start(self.config)\n    self.depth_sensor = self.profile.get_device().first_depth_sensor()\n    self.depth_scale = self.depth_sensor.get_depth_scale()\n    self.clipping_distance = clipping_distance_in_meters / self.depth_scale\n    self.align = rs.align(rs.stream.color)\n", "test": "def test_librealsense_get_frame(camera_obj):\n    assert camera_obj.get_frame()", "framework": "pytest"}
{"code": "def read_magic(fp):\n    \"\"\" Read the magic string to get the version of the file format.\n\n    Parameters\n    ----------\n    fp : filelike object\n\n    Returns\n    -------\n    major : int\n    minor : int\n    \"\"\"\n    magic_str = _read_bytes(fp, MAGIC_LEN, 'magic string')\n    if magic_str[:-2] != MAGIC_PREFIX:\n        msg = 'the magic string is not correct; expected %r, got %r'\n        raise ValueError(msg % (MAGIC_PREFIX, magic_str[:-2]))\n    if sys.version_info[0] < 3:\n        major, minor = map(ord, magic_str[-2:])\n    else:\n        major, minor = magic_str[-2:]\n    return (major, minor)\ndef _check_version(version): ...\ndef magic(major, minor): ...\ndef read_magic(fp): ...\ndef dtype_to_descr(dtype): ...\ndef header_data_from_array_1_0(array): ...\ndef _write_array_header(fp, d, version=None): ...\ndef write_array_header_1_0(fp, d): ...\ndef write_array_header_2_0(fp, d): ...\ndef read_array_header_1_0(fp): ...\ndef read_array_header_2_0(fp): ...\ndef _filter_header(s): ...\ndef _read_array_header(fp, version): ...\ndef write_array(fp, array, version=None, allow_pickle=True, pickle_kwargs=None): ...\ndef read_array(fp, allow_pickle=True, pickle_kwargs=None): ...\ndef open_memmap(filename, mode='r+', dtype=None, shape=None, fortran_order=False, version=None): ...\ndef _read_bytes(fp, size, error_template='ran out of data'): ...\n", "test": "def test_read_magic():\n    s1 = BytesIO()\n    s2 = BytesIO()\n    arr = np.ones((3, 6), dtype=float)\n    format.write_array(s1, arr, version=(1, 0))\n    format.write_array(s2, arr, version=(2, 0))\n    s1.seek(0)\n    s2.seek(0)\n    version1 = format.read_magic(s1)\n    version2 = format.read_magic(s2)\n    assert_(version1 == (1, 0))\n    assert_(version2 == (2, 0))\n    assert_(s1.tell() == format.MAGIC_LEN)\n    assert_(s2.tell() == format.MAGIC_LEN)", "framework": "pytest"}
{"code": "def read_array_header_1_0(fp):\n    \"\"\"\n    Read an array header from a filelike object using the 1.0 file format\n    version.\n\n    This will leave the file object located just after the header.\n\n    Parameters\n    ----------\n    fp : filelike object\n        A file object or something with a `.read()` method like a file.\n\n    Returns\n    -------\n    shape : tuple of int\n        The shape of the array.\n    fortran_order : bool\n        The array data will be written out directly if it is either\n        C-contiguous or Fortran-contiguous. Otherwise, it will be made\n        contiguous before writing it out.\n    dtype : dtype\n        The dtype of the file's data.\n\n    Raises\n    ------\n    ValueError\n        If the data is invalid.\n\n    \"\"\"\n    return _read_array_header(fp, version=(1, 0))\ndef _check_version(version): ...\ndef magic(major, minor): ...\ndef read_magic(fp): ...\ndef dtype_to_descr(dtype): ...\ndef header_data_from_array_1_0(array): ...\ndef _write_array_header(fp, d, version=None): ...\ndef write_array_header_1_0(fp, d): ...\ndef write_array_header_2_0(fp, d): ...\ndef read_array_header_1_0(fp): ...\ndef read_array_header_2_0(fp): ...\ndef _filter_header(s): ...\ndef _read_array_header(fp, version): ...\ndef write_array(fp, array, version=None, allow_pickle=True, pickle_kwargs=None): ...\ndef read_array(fp, allow_pickle=True, pickle_kwargs=None): ...\ndef open_memmap(filename, mode='r+', dtype=None, shape=None, fortran_order=False, version=None): ...\ndef _read_bytes(fp, size, error_template='ran out of data'): ...\n", "test": "def test_read_array_header_1_0():\n    s = BytesIO()\n    arr = np.ones((3, 6), dtype=float)\n    format.write_array(s, arr, version=(1, 0))\n    s.seek(format.MAGIC_LEN)\n    shape, fortran, dtype = format.read_array_header_1_0(s)\n    assert_(s.tell() % format.ARRAY_ALIGN == 0)\n    assert_((shape, fortran, dtype) == ((3, 6), False, float))", "framework": "pytest"}
{"code": "def read_array_header_2_0(fp):\n    \"\"\"\n    Read an array header from a filelike object using the 2.0 file format\n    version.\n\n    This will leave the file object located just after the header.\n\n    .. versionadded:: 1.9.0\n\n    Parameters\n    ----------\n    fp : filelike object\n        A file object or something with a `.read()` method like a file.\n\n    Returns\n    -------\n    shape : tuple of int\n        The shape of the array.\n    fortran_order : bool\n        The array data will be written out directly if it is either\n        C-contiguous or Fortran-contiguous. Otherwise, it will be made\n        contiguous before writing it out.\n    dtype : dtype\n        The dtype of the file's data.\n\n    Raises\n    ------\n    ValueError\n        If the data is invalid.\n\n    \"\"\"\n    return _read_array_header(fp, version=(2, 0))\ndef _check_version(version): ...\ndef magic(major, minor): ...\ndef read_magic(fp): ...\ndef dtype_to_descr(dtype): ...\ndef header_data_from_array_1_0(array): ...\ndef _write_array_header(fp, d, version=None): ...\ndef write_array_header_1_0(fp, d): ...\ndef write_array_header_2_0(fp, d): ...\ndef read_array_header_1_0(fp): ...\ndef read_array_header_2_0(fp): ...\ndef _filter_header(s): ...\ndef _read_array_header(fp, version): ...\ndef write_array(fp, array, version=None, allow_pickle=True, pickle_kwargs=None): ...\ndef read_array(fp, allow_pickle=True, pickle_kwargs=None): ...\ndef open_memmap(filename, mode='r+', dtype=None, shape=None, fortran_order=False, version=None): ...\ndef _read_bytes(fp, size, error_template='ran out of data'): ...\n", "test": "def test_read_array_header_2_0():\n    s = BytesIO()\n    arr = np.ones((3, 6), dtype=float)\n    format.write_array(s, arr, version=(2, 0))\n    s.seek(format.MAGIC_LEN)\n    shape, fortran, dtype = format.read_array_header_2_0(s)\n    assert_(s.tell() % format.ARRAY_ALIGN == 0)\n    assert_((shape, fortran, dtype) == ((3, 6), False, float))", "framework": "pytest"}
{"code": "class Config(object):\n    def verify(self):\n        sections = self.config.sections()\n        for section in sections:\n            try:\n                sec = self.setting.get(section)\n            except:\n                if section != 'misc':\n                    raise\n            for option in self.config.options(section):\n                sec.get(option)\n    \n    def __init__(self, config, setting): ...\n    def get_section(self, section): ...\n\n    self.config = config\n    self.setting = setting\n", "test": "def test_verify(self):\n    u\"\"\"\n        \u8a2d\u5b9a\u3068\u30d5\u30a1\u30a4\u30eb\u306e\u30c1\u30a7\u30c3\u30af\n        \"\"\"\n    setting = config.ConfigSetting()\n    setting.add_section('aaa', ['a', 'b', 'c'], dict(a=10, b=20))\n    parser = configparser.ConfigParser()\n    parser.add_section('aaa')\n    c = config.Config(parser, setting)\n    c.verify()\n    parser.add_section('bbb')\n    with self.assertRaises(ValueError):\n        c.verify()\n    parser = configparser.ConfigParser()\n    parser.add_section('aaa')\n    parser.set('aaa', 'b')\n    c = config.Config(parser, setting)\n    c.verify()\n    parser.set('aaa', 'd')\n    with self.assertRaises(ValueError):\n        c.verify()", "framework": "unittest"}
{"code": "class Tag(PageElement):\n    def decode(self, indent_level=None, eventual_encoding=DEFAULT_OUTPUT_ENCODING, formatter='minimal'):\n        \"\"\"Returns a Unicode representation of this tag and its contents.\n    \n            :param eventual_encoding: The tag is destined to be\n               encoded into this encoding. This method is _not_\n               responsible for performing that encoding. This information\n               is passed in so that it can be substituted in if the\n               document contains a <META> tag that mentions the document's\n               encoding.\n            \"\"\"\n        if not isinstance(formatter, collections.Callable):\n            formatter = self._formatter_for_name(formatter)\n        attrs = []\n        if self.attrs:\n            for key, val in sorted(self.attrs.items()):\n                if val is None:\n                    decoded = key\n                else:\n                    if isinstance(val, list) or isinstance(val, tuple):\n                        val = ' '.join(val)\n                    elif not isinstance(val, str):\n                        val = str(val)\n                    elif isinstance(val, AttributeValueWithCharsetSubstitution) and eventual_encoding is not None:\n                        val = val.encode(eventual_encoding)\n                    text = self.format_string(val, formatter)\n                    decoded = str(key) + '=' + EntitySubstitution.quoted_attribute_value(text)\n                attrs.append(decoded)\n        close = ''\n        closeTag = ''\n        prefix = ''\n        if self.prefix:\n            prefix = self.prefix + ':'\n        if self.is_empty_element:\n            close = '/'\n        else:\n            closeTag = '</%s%s>' % (prefix, self.name)\n        pretty_print = self._should_pretty_print(indent_level)\n        space = ''\n        indent_space = ''\n        if indent_level is not None:\n            indent_space = ' ' * (indent_level - 1)\n        if pretty_print:\n            space = indent_space\n            indent_contents = indent_level + 1\n        else:\n            indent_contents = None\n        contents = self.decode_contents(indent_contents, eventual_encoding, formatter)\n        if self.hidden:\n            s = contents\n        else:\n            s = []\n            attribute_string = ''\n            if attrs:\n                attribute_string = ' ' + ' '.join(attrs)\n            if indent_level is not None:\n                s.append(indent_space)\n            s.append('<%s%s%s%s>' % (prefix, self.name, attribute_string, close))\n            if pretty_print:\n                s.append('\\n')\n            s.append(contents)\n            if pretty_print and contents and (contents[-1] != '\\n'):\n                s.append('\\n')\n            if pretty_print and closeTag:\n                s.append(space)\n            s.append(closeTag)\n            if indent_level is not None and closeTag and self.next_sibling:\n                s.append('\\n')\n            s = ''.join(s)\n        return s\n    \n    def __init__(self, parser=None, builder=None, name=None, namespace=None, prefix=None, attrs=None, parent=None, previous=None): ...\n    def __copy__(self): ...\n    def is_empty_element(self): ...\n    def string(self): ...\n    def string(self, string): ...\n    def _all_strings(self, strip=False, types=(NavigableString, CData)): ...\n    def stripped_strings(self): ...\n    def get_text(self, separator='', strip=False, types=(NavigableString, CData)): ...\n    def decompose(self): ...\n    def clear(self, decompose=False): ...\n    def index(self, element): ...\n    def get(self, key, default=None): ...\n    def has_attr(self, key): ...\n    def __hash__(self): ...\n    def __getitem__(self, key): ...\n    def __iter__(self): ...\n    def __len__(self): ...\n    def __contains__(self, x): ...\n    def __bool__(self): ...\n    def __setitem__(self, key, value): ...\n    def __delitem__(self, key): ...\n    def __call__(self, *args, **kwargs): ...\n    def __getattr__(self, tag): ...\n    def __eq__(self, other): ...\n    def __ne__(self, other): ...\n    def __repr__(self, encoding='unicode-escape'): ...\n    def __unicode__(self): ...\n    def __str__(self): ...\n    def encode(self, encoding=DEFAULT_OUTPUT_ENCODING, indent_level=None, formatter='minimal', errors='xmlcharrefreplace'): ...\n    def _should_pretty_print(self, indent_level): ...\n    def prettify(self, encoding=None, formatter='minimal'): ...\n    def decode_contents(self, indent_level=None, eventual_encoding=DEFAULT_OUTPUT_ENCODING, formatter='minimal'): ...\n    def encode_contents(self, indent_level=None, encoding=DEFAULT_OUTPUT_ENCODING, formatter='minimal'): ...\n    def renderContents(self, encoding=DEFAULT_OUTPUT_ENCODING, prettyPrint=False, indentLevel=0): ...\n    def find(self, name=None, attrs={}, recursive=True, text=None, **kwargs): ...\n    def find_all(self, name=None, attrs={}, recursive=True, text=None, limit=None, **kwargs): ...\n    def children(self): ...\n    def descendants(self): ...\n    def select_one(self, selector): ...\n    def select(self, selector, _candidate_generator=None, limit=None): ...\n    def childGenerator(self): ...\n    def recursiveChildGenerator(self): ...\n    def has_key(self, key): ...\n\n    self.name = name\n    self.namespace = namespace\n    self.prefix = prefix\n    self.attrs = attrs\n    self.contents = []\n    self.hidden = False\n\n    parserClass = _alias('parser_class')\n    isSelfClosing = is_empty_element\n    strings = property(_all_strings)\n    getText = get_text\n    text = property(get_text)\n    findChild = find\n    findAll = find_all\n    findChildren = find_all\n    _selector_combinators = ['>', '+', '~']\n    _select_debug = False\n", "test": "def test_real_shift_jis_document(self):\n    shift_jis_html = b'<html><head></head><body><pre>\\x82\\xb1\\x82\\xea\\x82\\xcdShift-JIS\\x82\\xc5\\x83R\\x81[\\x83f\\x83B\\x83\\x93\\x83O\\x82\\xb3\\x82\\xea\\x82\\xbd\\x93\\xfa\\x96{\\x8c\\xea\\x82\\xcc\\x83t\\x83@\\x83C\\x83\\x8b\\x82\\xc5\\x82\\xb7\\x81B</pre></body></html>'\n    unicode_html = shift_jis_html.decode('shift-jis')\n    soup = self.soup(unicode_html)\n    self.assertEqual(soup.encode('utf-8'), unicode_html.encode('utf-8'))\n    self.assertEqual(soup.encode('euc_jp'), unicode_html.encode('euc_jp'))", "framework": "unittest"}
{"code": "class Tag(PageElement):\n    def decode(self, indent_level=None, eventual_encoding=DEFAULT_OUTPUT_ENCODING, formatter='minimal'):\n        \"\"\"Returns a Unicode representation of this tag and its contents.\n    \n            :param eventual_encoding: The tag is destined to be\n               encoded into this encoding. This method is _not_\n               responsible for performing that encoding. This information\n               is passed in so that it can be substituted in if the\n               document contains a <META> tag that mentions the document's\n               encoding.\n            \"\"\"\n        if not isinstance(formatter, collections.Callable):\n            formatter = self._formatter_for_name(formatter)\n        attrs = []\n        if self.attrs:\n            for key, val in sorted(self.attrs.items()):\n                if val is None:\n                    decoded = key\n                else:\n                    if isinstance(val, list) or isinstance(val, tuple):\n                        val = ' '.join(val)\n                    elif not isinstance(val, str):\n                        val = str(val)\n                    elif isinstance(val, AttributeValueWithCharsetSubstitution) and eventual_encoding is not None:\n                        val = val.encode(eventual_encoding)\n                    text = self.format_string(val, formatter)\n                    decoded = str(key) + '=' + EntitySubstitution.quoted_attribute_value(text)\n                attrs.append(decoded)\n        close = ''\n        closeTag = ''\n        prefix = ''\n        if self.prefix:\n            prefix = self.prefix + ':'\n        if self.is_empty_element:\n            close = '/'\n        else:\n            closeTag = '</%s%s>' % (prefix, self.name)\n        pretty_print = self._should_pretty_print(indent_level)\n        space = ''\n        indent_space = ''\n        if indent_level is not None:\n            indent_space = ' ' * (indent_level - 1)\n        if pretty_print:\n            space = indent_space\n            indent_contents = indent_level + 1\n        else:\n            indent_contents = None\n        contents = self.decode_contents(indent_contents, eventual_encoding, formatter)\n        if self.hidden:\n            s = contents\n        else:\n            s = []\n            attribute_string = ''\n            if attrs:\n                attribute_string = ' ' + ' '.join(attrs)\n            if indent_level is not None:\n                s.append(indent_space)\n            s.append('<%s%s%s%s>' % (prefix, self.name, attribute_string, close))\n            if pretty_print:\n                s.append('\\n')\n            s.append(contents)\n            if pretty_print and contents and (contents[-1] != '\\n'):\n                s.append('\\n')\n            if pretty_print and closeTag:\n                s.append(space)\n            s.append(closeTag)\n            if indent_level is not None and closeTag and self.next_sibling:\n                s.append('\\n')\n            s = ''.join(s)\n        return s\n    \n    def __init__(self, parser=None, builder=None, name=None, namespace=None, prefix=None, attrs=None, parent=None, previous=None): ...\n    def __copy__(self): ...\n    def is_empty_element(self): ...\n    def string(self): ...\n    def string(self, string): ...\n    def _all_strings(self, strip=False, types=(NavigableString, CData)): ...\n    def stripped_strings(self): ...\n    def get_text(self, separator='', strip=False, types=(NavigableString, CData)): ...\n    def decompose(self): ...\n    def clear(self, decompose=False): ...\n    def index(self, element): ...\n    def get(self, key, default=None): ...\n    def has_attr(self, key): ...\n    def __hash__(self): ...\n    def __getitem__(self, key): ...\n    def __iter__(self): ...\n    def __len__(self): ...\n    def __contains__(self, x): ...\n    def __bool__(self): ...\n    def __setitem__(self, key, value): ...\n    def __delitem__(self, key): ...\n    def __call__(self, *args, **kwargs): ...\n    def __getattr__(self, tag): ...\n    def __eq__(self, other): ...\n    def __ne__(self, other): ...\n    def __repr__(self, encoding='unicode-escape'): ...\n    def __unicode__(self): ...\n    def __str__(self): ...\n    def encode(self, encoding=DEFAULT_OUTPUT_ENCODING, indent_level=None, formatter='minimal', errors='xmlcharrefreplace'): ...\n    def _should_pretty_print(self, indent_level): ...\n    def prettify(self, encoding=None, formatter='minimal'): ...\n    def decode_contents(self, indent_level=None, eventual_encoding=DEFAULT_OUTPUT_ENCODING, formatter='minimal'): ...\n    def encode_contents(self, indent_level=None, encoding=DEFAULT_OUTPUT_ENCODING, formatter='minimal'): ...\n    def renderContents(self, encoding=DEFAULT_OUTPUT_ENCODING, prettyPrint=False, indentLevel=0): ...\n    def find(self, name=None, attrs={}, recursive=True, text=None, **kwargs): ...\n    def find_all(self, name=None, attrs={}, recursive=True, text=None, limit=None, **kwargs): ...\n    def children(self): ...\n    def descendants(self): ...\n    def select_one(self, selector): ...\n    def select(self, selector, _candidate_generator=None, limit=None): ...\n    def childGenerator(self): ...\n    def recursiveChildGenerator(self): ...\n    def has_key(self, key): ...\n\n    self.name = name\n    self.namespace = namespace\n    self.prefix = prefix\n    self.attrs = attrs\n    self.contents = []\n    self.hidden = False\n\n    parserClass = _alias('parser_class')\n    isSelfClosing = is_empty_element\n    strings = property(_all_strings)\n    getText = get_text\n    text = property(get_text)\n    findChild = find\n    findAll = find_all\n    findChildren = find_all\n    _selector_combinators = ['>', '+', '~']\n    _select_debug = False\n", "test": "def test_real_hebrew_document(self):\n    hebrew_document = b'<html><head><title>Hebrew (ISO 8859-8) in Visual Directionality</title></head><body><h1>Hebrew (ISO 8859-8) in Visual Directionality</h1>\\xed\\xe5\\xec\\xf9</body></html>'\n    soup = self.soup(hebrew_document, from_encoding='iso8859-8')\n    self.assertEqual(soup.original_encoding, 'iso8859-8')\n    self.assertEqual(soup.encode('utf-8'), hebrew_document.decode('iso8859-8').encode('utf-8'))", "framework": "unittest"}
